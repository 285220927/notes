1）客户端调用create()方法创建名为“ locknode/lock-”的节点，需要注意的是，节点的创建类型需要设置为EPHEMERAL_SEQUENTIAL。

2）客户端调用getChildren(“locknode”)方法来获取所有已经创建的子节点。

3）客户端获取到所有子节点path之后，如果发现自己在步骤1）中创建的节点序号最小，那么就认为这个客户端获得了锁。

4）如果在步骤3）中发现自己并非所有子节点中最小的，说明集群中其他进程获取到了这把锁。此时客户端需要找到最小子节点，然后对其调用exist()方法，同时注册事件监听。

5）一旦最小子节点对应的进程释放了分布式锁，对应的临时节点就会被移除，客户端因为注册了事件监听而收到相应的通知。这个时候客户端需要再次调用getChildren("locknode")方法来获取所有已经创建的子节点，然后进入步骤3。



　12.3.5　无用代码的消除223
12.4　其他的测试方法224
12.4.1　代码审查224
12.4.2　静态分析工具224
12.4.3　面向方面的测试技术226
12.4.4　分析与监测工具226
第四部分　高级主题
第13章　显式锁227
13.1　Lock与 ReentrantLock227
13.1.1　轮询锁与定时锁228
13.1.2　可中断的锁获取操作230
13.1.3　非块结构的加锁231
13.2　性能考虑因素231
13.3　公平性232
13.4　在synchronized和ReentrantLock之间进行选择234
13.5　读-写锁235











第14章　构建自定义的同步工具238
14.1　状态依赖性的管理238
14.1.1　示例：将前提条件的失败传递给调用者240
14.1.2　示例：通过轮询与休眠来实现简单的阻塞241
14.1.3　条件队列243
14.2　使用条件队列244
14.2.1　条件谓词244
14.2.2　过早唤醒245
14.2.3　丢失的信号246
14.2.4　通知247
14.2.5　示例：阀门类248
14.2.6　子类的安全问题249
14.2.7　封装条件队列250
14.2.8　入口协议与出口协议250







14.3　显式的Condition对象251
14.4　Synchronizer剖析253
14.5　AbstractQueuedSynchronizer254
14.6　java.util.concurrent同步器类中的 AQS257
14.6.1　ReentrantLock257
14.6.2　Semaphore与CountDownLatch258
14.6.3　FutureTask259
14.6.4　ReentrantReadWriteLock259





15.1　锁的劣势261
15.2　硬件对并发的支持262
15.2.1　比较并交换263
15.2.2　非阻塞的计数器264
15.2.3　JVM对CAS的支持265
15.3　原子变量类265
15.3.1　原子变量是一种“更好的volatile”266
15.3.2　性能比较：锁与原子变量267
15.4　非阻塞算法270
15.4.1　非阻塞的栈270
15.4.2　非阻塞的链表272
15.4.3　原子的域更新器274
15.4.4　ABA问题275





16.1　什么是内存模型，为什么需要它277
16.1.1　平台的内存模型278
16.1.2　重排序278
16.1.3　Java内存模型简介280
16.1.4　借助同步281
16.2　发布283
16.2.1　不安全的发布283
16.2.2　安全的发布284
16.2.3　安全初始化模式284
16.2.4　双重检查加锁286
16.3　初始化过程中的安全性287
附录A　并发性标注289