---

title: "Interview"
date: 2020-07-29 00:00
tags: ["Interview","Spring","JUC","JVM","Structure","Cache"]
categories: "interview"
sticky: 1111
---
# 前言

仅供本人面试前准备，其他人还是别看了，没意义。有很多我缩写，省去了很多易理解的部分。

# 常见容器

## ArrayList 详解

https://note.youdao.com/ynoteshare1/index.html?id=efd2a3a29d2626acea2b053e56bae5cc&type=notebook#/04F1A0EFF8F241C2A89E2234AAF0A36A

1. 底层**基于数组**实现

2. **创建ArrayList如果不指定大小**，会先创建一个**大小为0的Object[ ]数组** ，

**第一次添加数据**时，会**扩容**成ArrayList的 默认大小**default_capacity：10****；**

3. 创建时如果**指定大小**，直接**创建指定大小的Object[ ]数组**

4. add（）

- 对 **size+1**，去**判断数组是否满了**，如果满了就**调用 grow（）方法扩容**，扩容大小为，**原数组大小 + 原数组大小右移一位**。也就是扩容到原来的**1.5倍**。jdk 1.6 是 1.5 倍 +1 ，JDK 1.7，1.8 是 1.5 倍。
- 然后把老数组拷贝到新数组里 

**elementData** = **Arrays.copyOf(elementData, newCapacity);**

- 最后 **elementData[ size++ ] = e**，对数组赋值，（并且size+1）

5. add（index，e）

- 首先**对index做数组越界检查rangeCheck(index)**;  如果越界了，抛数组越界异常
- 如果没越界，还是**对 size + 1，判断是否需要扩容**，如果需要扩容，调用**grow**方法
- 如果需要扩容，调用**System.arraycopy（1,2,3,4,5）**方法。参数解释**1：原来的数组，2：从哪里开始复制。3：复制的目标数组。4：目标数组的第几位开始复制。5：一共复制几个数**。
- System.arraycopy(elementData, index, elementData, index + 1, size - index);
- 假设把数字6插入到第3位，复制过后的数组是，1 2 3 4 5 -> **1 2 3 3 4 5** 
- 然后再把目标的位置的值修改，变为 **1 2 6 3 4 5** 
- 最后size++；

6. set（index，e）

- 首先解释，set这个方法是替换该位置原来的元素，所以不会使数组变大，不会做扩容判断
- 然后对index做数组越界检查，如果越界了，抛数组越界异常
- 把e替换到数组的index位置
- 返回数组index位置的原始值

7. remove（index）

- 首先**对index做数组越界检查rangeCheck(index);**，如果越界了，抛数组越界异常
- 然后进行**数组拷贝 System.arraycopy(elementData, index+1, elementData, index,size - index - 1);**
- 假设把第三位数字删除，**1 2 3 4 5 6 	- > 1	2 4 5 6 6**	
- **然后 element[size--] = null;**
- 最后**返回被删除的值**

8. get（index）

- 首先对index做数组越界检查**rangeCheck(index);**，如果越界了，抛数组越界异常
-  **return elementData(index);**

9. **总结来说，AraayList的get方法效率非常高，直接返回对应下标值，add方法和remove方法，效率就有点低了，需要考虑数组扩容和数组拷贝的问题****。**

10. **所以ArrayList比较适用于插入操作较少，不是很频繁插入的场景。**

## HashMap 详解

https://note.youdao.com/ynoteshare1/index.html?id=efd2a3a29d2626acea2b053e56bae5cc&type=notebook#/79C59785226E4D679AF124256055760B

1. **底层结构**是 数组 + 单向链表 + 红黑树 （jdk8之后），之前是数组 + 链表

**底层是，用node节点组成的数组**

```java
transient Node<K,V>[] table;              
```

2. 基于对存储数据，数据会被封装成一个Node节点，会存放它的hash值、key值、value值、next指针。

```java
//实现了Entry<K,V>    
static class Node<K,V> implements Map.Entry<K,V> { 
    //这个hash值是通过key的hashcode值经过hash算法得出来的      
    //做了异或操作        
    final int hash;     
    final K key;        
    V value;       
    Node<K,V> next;    
    boolean red;   
}    
```

3. 几个关键参数

- **初始容量**

```java
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16              
```

- **默认加载因子是0.75；**

```java
 static final float DEFAULT_LOAD_FACTOR = 0.75f; 
```

**扩容临界值（容量\*加载因子）;**

-  **这个东西不只是干了这个事，还有另一个作用**
- **在使用构造函数创建hashmap时，如果指定了容量，那构造函数里就要算出一个数来，必须是2的n次方 ，就是tableSizeFor方法。但是构造函数完成后也只是创建一个空数组，只有在第一次放数据时才会初始化容量，所以构造函数那里必须要保存计算出来的数。等到第一次放数据的时候用。threshold就是这个大小，构造函数阶段会算出这数的值。为什么用这个数保存数组大小，我觉得是作者觉得既然构造阶段数组没有初始化，那临界值也没什么意义，就临时当数组初始大小，等待put的时候给数组初始化，然后那时再回归他本身的意义，扩容临界值**。

```java
int threshold;              
```

- **size是集合当前大小** 

```java
transient int size;              
```

4. **构造函数有三种**	

- **无参**

```java
public HashMap() {        //负载因子默认 DEFAULT_LOAD_FACTOR = 0.75       
    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted  
}         
```

- **一个参数**

```java
//集合初始大小 initialCapacity     
public HashMap(int initialCapacity) {        //去调用下面两个参数的构造函数        
    this(initialCapacity, DEFAULT_LOAD_FACTOR);    
}              
```

- **两个参数**

```java
public HashMap(int initialCapacity, float loadFactor) { 
    if (initialCapacity < 0)            
        throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity);       
    if (initialCapacity > MAXIMUM_CAPACITY)  
        initialCapacity = MAXIMUM_CAPACITY;   
    if (loadFactor <= 0 || Float.isNaN(loadFactor)) 
        throw new IllegalArgumentException("Illegal load factor: " + loadFactor);        
    this.loadFactor = loadFactor;        
    this.threshold = tableSizeFor(initialCapacity);   
}       
```

5. **put**（K，V）方法，**hash算法 和 hash寻址算法**

- **put的时候，先通过hash算法处理hashcode，然后通过寻址算法定位到该元素在数组的位置，然后判断应该放在数组还是链表或者红黑树中**

- **hash算法**

```java
static final int hash(Object key) { 
    int h;       
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);   
}              
```

- **ps:hashcode是int型，4个字节，一个字节8个bit，一共32位**
- **先定义个变量： key的hashcode右移 16位，其实就是把原来的hashcode值的高16位放到低16位，高16位补0。然后画图讲解:**

​    ![0](data:image/jpeg;base64,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u32YTejFZcZDoa61rUBBqC+f0jNHzWtHRrK/aQfMA8RZStrCimdAe2Iv4cAi81Dkp9LyMrcWzaXEn+rOytuBsONWK/8AvdSNslLlDjXjSsF1pNYq3rNnD6DwcqMJamdoisJdqEapRSKOxPigwram4QT4of8AwpHfLn7IBCb8+bdEHlc6/L0844844844844844844844844844844844844844844844844844844845BrJq+tLmSjlbXBXaNa1dM2nTGZEGyVIA9JTBHjydM2PHOKzQPKAi2nRMjR5enVPgSNeqTo078McdurDPGooAHilThEaoyiOOCjoSKHBeCBNSLxaKlCStSCJX6uO8RakxaInlgzFDNpCUgpuMgbyO9hzcRazQorTWYmwy0maEpP3W9ZmtomJmOUD84C4Q+VX9or5xRyR8pH625P8A9pz5zfTnyq/r3nB1DMnX7XvxN/1H625DdGgdkyfRH8xlB06on2b9j68Nfy08y1KUsz+ic2hR50n/ANZQGe5yGGlJPKVaGIyyQtAeupLsHteJsUk2qDELw3C8QCH7jI9Af8odIGgRiu3FPH9NxDXBQdjedqUCGtZio6RX5ZeAuEXRDQqsceKeSWysKqwMa6vrhl5wpw6h1vgwz9xU/ghKBRNlLyfgcKSN5IxivDh3wnP3bpk35vkbM9mXhohhqrrEQd2ioUaNm/1aqkuMQl06sX8i1VAIABhXi8BEMIqUpWo6RHov8F7KA/xUsyVyyov817NnuQh2rBp4jlkxDGIU81kpLlJe9psS0z7PfBXDNpTEshZ3GHJ9jT63WQSVXc5750p9vmISarYYallSS5LAnENyssrmvVr1ggIPOCKEYa8MB8SPjhj8+X0YYFpl2xnMPZO2N8+vQt6aZnwkkwnSv1tDZGxFmSjZuWxqEmb1vFv++VXAAmcPIIEV8kKpEg5dx0tnCSKP1FUGlaJWGqQUQMi9RQK448LUmv8A1yfXhzDzV02NAhukueaN6EEKs6WTWBV4VKg2wNXCRDRrizyAGC+r5+KHnTYunTGlyx+qPvk6NWvTu2Z68McfmSy4LHG1YIrMhEZcLFh0k4gM3XIwEZpr7KCORVW5h1tFC3WXtetrBHNdUGNUJF6mLVcpRGKCCXgJDL0MMBiCifC5Q0ZYoIlqzcdGDVpNYKSLQB64K4YtGMgw7M4v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)

- - **相当于拿hashcode的低16为和高16位做异或操作（不一样的为1，一样的为0)，让高16位也参与到运算中（****正常来说集合的大小是不会特别大的****，****2的16次幂就6万多了****，虽然hashmap允许的最大值是2的30次幂），所以，hash值的后16位90%的情况下都不会参与运算。但是现在高16位和低16位异或后，****低16位就同时保留了高低两部分的特征，降低hash冲突。**

  - - **为什么说可以降低hash冲突，因为如果两个key，解析的hashcode可能低16为一样的，但是如果这么异或一下，就不一样了**

- **寻址算法:**

```java
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) {
    Node<K,V>[] tab; 
    Node<K,V> p; 
    int n, i;        //注意这里的 (n - 1) & hash       
    if ((p = tab[i = (n - 1) & hash]) == null)      
        tab[i] = newNode(hash, key, value, null); 
    else {       //省略下面的代码...     
    }
}         
```

- **寻址算法，会拿经过hash算法的hashcode 跟 （****数组大小 - 1****），做与操作，这样做相当于对数组大小取模，但是效率上要比取模高的多，直接做位运算省去了转成10进制的步骤，但是这么做有一个前提，****集合大小必须是**2的n次方

    - **这里解释下为什么** **只有集合大小是2的n次方，他们与操作才等同于取模**

    - **假设，数组大小为 （2的3次方 - 1 ） = 7**
    - **那么，二进制表示，就是 1  1  1**
    - **与操作的意思是，只有两边都是1，才是1**
    - **因为，数组大小为7，二进制 1 1 1，前面都是0补全的**
    - **那么，hashcode的二进制除了后3位，其他的就没意义了****，因为要做与操作，而****数组的前面都是0，不管hashcode前面是1还是0，都没有用****，做完与操作就是0**
    - **那么hashcode的有效长度只有后三位，****共有8种情况**

```code
  0  0  0	=	0
  0  0  1	=	1 
  0  1  0	=	2 
  0  1  1	=	3 
  1  0  0	=	4 
  1  0  1	=	5 
  1  1  0	=	6              
```
 **跟数组大小的二进制 1 1 1做与操作**，那就是
```code
  0  0  0  &  1  1  1  =	0	ps: 0 % 7 余 7 
  0  0  1  &  1  1  1  =	1	ps: 1 % 7 余 1
  0  1  0  &  1  1  1  =	2	ps: 2 % 7 余 2
  0  1  1  &  1  1  1  =	3	ps: 3 % 7 余 3 
  1  0  0  &  1  1  1  =	4	ps: 4 % 7 余 4
  1  0  1  &  1  1  1  =	5	ps: 5 % 7 余 5 
  1  1  0  &  1  1  1  =	6	ps: 6 % 7 余 6 
  1  1  1  &  1  1  1  =	7	ps: 7 % 7 余 0
```

- **发现没有，这样就跟取模是一个效果。**

- **如果不设成2的n次方，那****数组的二进制****就有可能是**  **0  1  0** **，那****hashcode的有效值就变成1位了****，****那数组中有的地方一直没元素，有的地方一直冲突**

- **判断该元素存放在哪里**

  - **如果hash寻址之后，这个位置的元素为null，那么直接放里**
  - **如果这个位置的元素不为空，会走一个遍历，这个元素的.next，为null停**
  - **进入循环之后，先判断，hash值是否相等（即使hash值不相等，也可能定位到同一个位置），key的equals是否相等，如果满足这两个条件，说明这两个元素的key是一样的，直接替换掉，循环break**
  - **如果那两个条件不成立，说明hash冲突，那么会一直循环到最后一个元素，如果没有一个元素符合上述两个条件，那么最后一个元素的next指向本次插入的元素**
  - **本次put操作暂不考虑红黑树情况，下节讲，当链表的大小长度大于等于8的时候，会字段转换成红黑树**
  - **如果不转红黑树，当链表过长的时候，时间复杂度会变成O（n）**

6. HashMap 如何保证容量一直是2的N次方，如果构造函数传的不是2的n次方呢？

- hashMap有一个tableSizeFor方法，会保证集合的容量是2的N次方，大小是比入参值大，并且离入参值最近的2的N次方那个数

  - 如入参:0    容量：0
  - 入参:1    容量：1
  - 入参:2    容量：2
  - 入参:3    容量：4
  - 入参:4    容量：4
  - 入参:5    容量：8

代码

```java
/** 
* Returns a power of two size for the given target capacity.
*/ 
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;   
    n |= n >>> 2;
    n |= n >>> 4; 
    n |= n >>> 8;  
    n |= n >>> 16;  
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; 
}      
```

- | ，或操作， 0和1，则为1

- \>>> ， 无符号右移（这个其实用 >> 和用 >>> 没什么区别）

- 第6行，自己右移一位和自己做或操作

- 第7行，自己右移两位和自己做或操作

- 第8行，自己右移4位和自己做或操作

- 一直到第10行，都是

- 那么，加起来，一共右移了35位

- 总结下，这个算法要做的事是啥，就是要把2进制的，把你从最高位开始，后面的全变成1，最后返回结果又加1，就变成2的n次方了

- 刚开始为什么要减一呢，就是为了临界值，如果你传的已经是2的n次方了，如果不减一，算出来的就是16了（把8的二进制，后面都变成1，结果又加1，就变成16了），如果减一，那就是7，把7的后面都变成1，再加1，那是8。所以最开始第5行，先减一

- 如果还没看懂看下面的

- https://blog.csdn.net/fan2012huan/article/details/51097331

6. get（Key），hash寻址

**hash寻址，寻址到了判断 hash值   和equals ， 如果有链表和数再遍历**

7. remove（Key）

**寻址到了设为空，size--**

8. 红黑树是什么

[红黑树.note](note://0026C4573DC34C9F9F21EE16F4F98E07)

9. 扩容

https://blog.csdn.net/u013494765/article/details/77837338

**===========================下面为拓展=============================**

转成红黑树后，会变成 TreeNode

```java
static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {        
    TreeNode<K,V> parent;  // red-black tree links 
    TreeNode<K,V> left;        
    TreeNode<K,V> right;        
    TreeNode<K,V> prev;    // needed to unlink next upon deletion        
    boolean red;        
    TreeNode(int hash, K key, V val, Node<K,V> next) {
        super(hash, key, val, next);        
    }    //下面省略 
}      
```

- JDK 1.7 的hashMap 在并发情况下导致死循环的问题

- https://www.jianshu.com/p/619a8efcf589

## LinkedList 详解

[自行查看](https://note.youdao.com/ynoteshare1/index.html?id=efd2a3a29d2626acea2b053e56bae5cc&type=notebook#/1253A2DE5549471CAD0EE89666BD208D)

1. LinkedList 底层是基双向链表实现的

2. LinkedList的每条数据都会被封装成 Node

```java
private static class Node<E> {    
    E item;     
    Node<E> next;   
    Node<E> prev;      
    //构造方法       
    Node(Node<E> prev, E element, Node<E> next) { 
        this.item = element;            
        this.next = next;           
        this.prev = prev;        
    }  
}      
```

## ArrayBlockingQueue 详解

用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下 不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当 队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入 元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐 量。我们可以使用以下代码创建一个公平的阻塞队列：

```java
ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000,true);
```

## LinkedBlockingQueue 详解

基于链表的阻塞队列，同 ArrayListBlockingQueue 类似，此队列按照先进先出（FIFO）的原则对 元素进行排序。而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者 端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费 者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。

LinkedBlockingQueue 会默认一个类似无限大小的容量（Integer.MAX_VALUE）。

## ConcurrentHashMap详解

1.7分段数组+单向链表

1.8其中抛弃了原有的 Segment 分段锁，而采用了 `CAS + synchronized` 来保证并发安全性。

https://www.jianshu.com/p/aa017a3ddc40

## CopyOnWriteArrayList

# IO

# NIO

# Reflect

## Class

## Method

## Constructor

## ClassLoader

# JVM

## 内存结构

## GC 算法

### 标记清除（Mark-Sweep）

分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清 除阶段回收被标记的对象所占用的空间，容易产生内存碎片。

### 复制（copying）

按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。消耗内存多，但是没有内存碎片产生，用于新生代对象创建。

### 标记整理(Mark-Compact)

标记后不是清理对象，而是将存活对象移向内存的一端，然后清除端边界外的对象。

和指针碰撞不同

### 分代收集算法

根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃 圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。

### 新生代与复制算法

目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要 回收大部分对象，即要复制的操作比较少，但通常并不是按照 1：1 来划分新生代。一般将新生代 划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用 Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另 一块 Survivor 空间中。

### 老年代与标记复制算法

而老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。

1. JAVA 虚拟机提到过的处于方法区的永生代(Permanet Generation)，它用来存储 class 类， 常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。
2. 对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor 目 前存放对象的那一块)，少数情况会直接分配到老生代。
3. 当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后，Eden Space 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 From Space 进行清理。
4. 如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。
5. 在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。
6. 当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。默认情况下年龄到达 15 的对象会被 移到老生代中。

## JAVA 四中引用类型

### 强引用

把一个对象赋给一个引用变量，这个引用变量就是一个强引 用。当一个对象被强引用变量引用时

### 软引用

软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它 不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。

### 弱引用

弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象 来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。

### 虚引用

虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚 引用的主要作用是跟踪对象被垃圾回收的状态。

## 什么是 Safepoint

safepoint可以用在不同地方，比如GC、Deoptimization，在Hotspot VM中，GC safepoint比较常见，需要一个数据结构记录每个线程的调用栈、寄存器等一些重要的数据区域里什么地方包含了GC管理的指针。

从线程角度看，safepoint可以理解成是在代码执行过程中的一些特殊位置，当线程执行到这些位置的时候，说明虚拟机当前的状态是安全的，如果有需要，可以在这个位置暂停，比如发生GC时，需要暂停暂停所以活动线程，但是线程在这个时刻，还没有执行到一个安全点，所以该线程应该继续执行，到达下一个安全点的时候暂停，等待GC结束。

https://www.jianshu.com/p/c79c5e02ebe6

## Minor GC 和 Full GC 的触发机制

[JVM 系列文章之 Full GC 和 Minor GC](https://juejin.im/post/5b8d2a5551882542ba1ddcf8)
 from区 to区，反复横跳，进入老年代

+ young区
  + Eden 80%
  + from 10%
  + to 10%
+ old区 

设置参数，可让创建对象时，直接进入old区

-XX:MaxTenuringThreshold=15 cms里面默认是6，

## 大对象为什么直接进入老年代

虚拟机提供了一个`-XX:PretenureSizeThreshold`参数，不同垃圾收集器默认值不同，直接在 Eden 区。大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区（`from`区`to`区）之间发生大量的内存复制。不同分代，采用不同垃圾回收算法，young区采用的是复制清除算法，如果是大对象，就得不偿失了。

注意:`PretenureSizeThreshold`参数只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数，Parallel Scavenge收集器一般并不需要设置。如果遇到必须使用此参数的场合，可以考虑ParNew加CMS的收集器组合。

一个简单的方法，在 Spring Boot项目中写个 循环依赖 类，然后用 类层次 类去引用，再Debug，就能看见 栈溢出信息，和 from to区的信息。

## JVM 调优

1. -Xms -Xmx 设置成一样 。例如 -Xms2048M -Xmx2048M

2. -XX:USEBAISEDLOCKED=FALSE 关闭偏向锁。JDK 1.6引入新概念，在线程竞争不激烈时引入，偏向锁，轻量级锁。支持锁的升级和降级，但并发比较大的环境下，关掉这个是好的选择。在对象头中标出，00，01，10，11，两位标出是什么状态。

3. 年轻代：-XX:+UseParNewGC。

   老年代：-XX:+UseConcMarkSweepGC。

4. `-XX:-DoEscapeAnalysis` ： 表示关闭逃逸分析 从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis。逃逸分析是让某些朝生夕死的对象，在栈上创建对象，随着栈的消亡而消亡。

   https://www.hollischuang.com/archives/2583

5. 频繁触发 Full GC ，如果使用的是 G1，可以加上 -XX:+PrintAdaptiveSizePolicy 参数，查看到底是谁引发的

6. 更多见https://www.jianshu.com/p/9e6452124a3d

## 字节码编译过程

https://www.cnblogs.com/straybirds/p/8513870.html

各种验证，各种解析，解析成树，具体内容在 《深入理解Java虚拟机》中有讲解

## 什么情况会发生 OOM

// TODO 补充说明

# 多线程

## Volatile 如何保证内存可见性

volatile 是 Java 提供的轻量级同步机制

+ 保证可见性

+ 不保证原子性

+ 禁止指令重排

JMM（Java Memory Model）本身是一种抽象的概念，并不真实存在，它描述的一组规则或规范，通过这组规范定义了程序中各个变量（含实例字段，静态字段和构成数组对象的元素）的访问方式。

JMM关于同步的规定：

1. 线程解锁前必须把共享变量的值刷新回主存
2. 线程加锁前，必须读取主存的最新值到自己的工作内存
3. 加锁解锁是同一把锁

更多https://blog.csdn.net/t894690230/article/details/50588129

## happens-before

1. 程序次序法则：如果在程序中，所有动作 A 出现在动作 B 之前，则线程中的每动作 A 都 happens-before 于该线程中的每一个动作 B。
2. 监视器锁法则：对一个监视器的解锁 happens-before 于每个后续对同一监视器的加锁。
3. Volatile 变量法则：对 Volatile 域的写入操作 happens-before 于每个后续对同一 Volatile 的读操作。
4. 传递性：如果 A happens-before 于 B，且 B happens-before C，则 A happens-before C。

https://juejin.im/post/5ae6d309518825673123fd0e

https://en.wikipedia.org/wiki/Happened-before

## Synchronized C++ 实现源码解析

[synchronized.cpp解析](https://www.jianshu.com/p/c5058b6fe8e5)

Jdk1.6 锁的升级与降级，自旋锁->偏向锁->轻量级锁->重量级锁（操作系统内核的 mutex lock）

## ThreadLocal

https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/ThreadLocal.md

SpringMVC 中，RequestHolder 使用 ThreadLocal 进行 HttpServletRequest 进行缓存。

## AQS

https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/AQS.md

Doug Lea 设计的，CountDownLatch、ReentrantLock 都继承这个类，是 Java 最低层级的同步机制。

AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器。

###  AQS 原理概览

AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。

### AQS 对资源的共享方式

1. Exclusive（独占）

只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁,ReentrantLock 同时支持两种锁,下面以 ReentrantLock 对这两种锁的定义做介绍：

- 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁
- 非公平锁：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。

2. Share（共享）

多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。

ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。

不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在上层已经帮我们实现好了。

## Fork/Join

https://time.geekbang.org/column/article/92524

Fork/Join 是一个并行计算的框架，主要就是用来支持分治任务模型的，这个计算框架里的 Fork 对应的是分治任务模型里的任务分解，Join 对应的是结果合并。Fork/Join 计算框架主要包含两部分，一部分是分治任务的线程池 ForkJoinPool，另一部分是分治任务 ForkJoinTask。这两部分的关系类似于 ThreadPoolExecutor 和 Runnable 的关系，都可以理解为提交任务到线程池，只不过分治任务有自己独特类型 ForkJoinTask。

ForkJoinTask 是一个抽象类，它的方法有很多，最核心的是 fork() 方法和 join() 方法，其中 fork() 方法会异步地执行一个子任务，而 join() 方法则会阻塞当前线程来等待子任务的执行结果。ForkJoinTask 有两个子类——RecursiveAction 和 RecursiveTask，通过名字你就应该能知道，它们都是用递归的方式来处理分治任务的。这两个子类都定义了抽象方法 compute()，不过区别是 RecursiveAction 定义的 compute() 没有返回值，而 RecursiveTask 定义的 compute() 方法是有返回值的。这两个子类也是抽象类，在使用的时候，需要你定义子类去扩展。

Fork/Join 并行计算的核心组件是 ForkJoinPool。ForkJoinPool 本质上也是一个生产者 - 消费者的实现，但是更加智。ThreadPoolExecutor 内部只有一个任务队列，而 ForkJoinPool 内部有多个任务队列，当我们通过 ForkJoinPool 的 invoke() 或者 submit() 方法提交任务时，ForkJoinPool 根据一定的路由规则把任务提交到一个任务队列中，如果任务在执行过程中会创建出子任务，那么子任务会提交到工作线程对应的任务队列中。

如果工作线程对应的任务队列空了，是不是就没活儿干了呢？不是的，ForkJoinPool 支持一种叫做“任务窃取”的机制，如果工作线程空闲了，那它可以“窃取”其他工作任务队列里的任务，例如下图中，线程 T2 对应的任务队列已经空了，它可以“窃取”线程 T1 对应的任务队列的任务。如此一来，所有的工作线程都不会闲下来了。ForkJoinPool 中的任务队列采用的是双端队列，工作线程正常获取任务和“窃取任务”分别是从任务队列不同的端消费，这样能避免很多不必要的数据竞争。我们这里介绍的仅仅是简化后的原理，ForkJoinPool 的实现远比我们这里介绍的复杂

Fork/Join 并行计算框架主要解决的是分治任务。分治的核心思想是“分而治之”：将一个大的任务拆分成小的子任务去解决，然后再把子任务的结果聚合起来从而得到最终结果。这个过程非常类似于大数据处理中的 MapReduce，所以你可以把 Fork/Join 看作单机版的 MapReduce。

Fork/Join 并行计算框架的核心组件是 ForkJoinPool。ForkJoinPool 支持任务窃取机制，能够让所有线程的工作量基本均衡，不会出现有的线程很忙，而有的线程很闲的状况，所以性能很好。Java 1.8 提供的 Stream API 里面并行流也是以 ForkJoinPool 为基础的。不过需要你注意的是，默认情况下所有的并行流计算都共享一个 ForkJoinPool，这个共享的 ForkJoinPool 默认的线程数是 CPU 的核数；如果所有的并行流计算都是 CPU 密集型计算的话，完全没有问题，但是如果存在 I/O 密集型的并行流计算，那么很可能会因为一个很慢的 I/O 计算而拖慢整个系统的性能。所以建议用不同的 ForkJoinPool 执行不同类型的计算任务。

## 死锁

 一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象。

### 死锁发生的条件

1. 互斥，共享资源 X 和 Y 只能被一个线程占用；

2. 占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；

3. 不可抢占，其他线程不能强行抢占线程 T1 占有的资源；

4. 循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。

破坏其中一个，就可以成功避免死锁的发生。

## CAS

全称是 Compare And Swap，即“比较并交换。

CAS 指令包含 3 个参数：共享变量的内存地址 A、用于比较的值 B 和共享变量的新值 C；并且只有当内存中地址 A 处的值等于 B 时，才能将内存中地址 A 处的值更新为新值 C。作为一条 CPU 指令，CAS 指令本身是能够保证原子性的。

## AtomicInteger

### 调用 unsafe 的 compareAndSwap native 方法

```java
public final boolean compareAndSet(int expect, int update) {
    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}
```

###  native 方法 compareAndSwapInt 在 Linux 下的 JDK 实现如下。

```c++
UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))
  UnsafeWrapper("Unsafe_CompareAndSwapInt");
  oop p = JNIHandles::resolve(obj);
  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);
  return (jint)(Atomic::cmpxchg(x, addr, e)) == e;
UNSAFE_END
```

### Atocmic::cmpxchg 在 x86 处理器架构下（Linux 下）的 JDK 实现

```code
> What I'm a bit uncertain about here is which barriers we need and which are optimal as it seems to be a bit different for different ARM versions, maybe somebody can enlighten me? Also I'm not sure how hotspot checks ARM version to make the appropriate decision.
>
> The proposed x86 implementation is much more straight forward (bsd, linux):
>
> inline jbyte Atomic::cmpxchg(jbyte exchange_value, volatile jbyte* dest, jbyte compare_value) {
>   int mp = os::is_MP();
>   jbyte result;
>   __asm__ volatile (LOCK_IF_MP(%4) "cmpxchgb %1,(%3)"
>                     : "=a" (result)
>                     : "q" (exchange_value), "a" (compare_value), "r" (dest), "r" (mp)
>                     : "cc", "memory");
>   return result;
> }
>
>>> The implementation of single byte Atomic::cmpxchg on x86 (and all other
>>> platforms) emulates the single byte cmpxchgb instruction using a loop of
>>> jint-sized load and cmpxchgl and code to dynamically align the destination
>>> address.
>>>
>>> This code is used for GC-code related to remembered sets currently.
>>>
>>> I have the changes on my platform (amd64, bsd) to simply use the native
>>> cmpxchgb instead but could provide a patch fixing this unnecessary
>>> performance glitch for all supported x86 if anybody wants this?
>>
>> I think that sounds good.
>> Would you mind looking at other cpu arches to see if they provide something
>> similar? It's ok if you can't build the code for the other arches, I can help
>> you with that.
>>
>> /Mikael
```
# Servelt 容器
## Tomcat
# Nginx

# Spring 

## Spring Bean 的加载过程

### Spring Bean 元信息配置阶段
   + 基于 XML、Properties 配置

     XMLBeanDefinitionReader#loadBeanDefinitions(String resourceUrl);

     BeanDefinitionReader 的实现类 AbstractBeanDefinitionReader，而 AbstractBeanDefinitionReader 有三个实现类。分别对应 XML、Properties、Groovy 文件读取方式。现在都不推荐用这几个。

```java
package org.springframework.beans.factory.support;

import org.springframework.beans.factory.BeanDefinitionStoreException;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.lang.Nullable;

public interface BeanDefinitionReader {
  BeanDefinitionRegistry getRegistry();

  @Nullable
  ResourceLoader getResourceLoader();

  @Nullable
  ClassLoader getBeanClassLoader();

  BeanNameGenerator getBeanNameGenerator();

  int loadBeanDefinitions(Resource var1) throws BeanDefinitionStoreException;

  int loadBeanDefinitions(Resource... var1) throws BeanDefinitionStoreException;

  int loadBeanDefinitions(String var1) throws BeanDefinitionStoreException;

  int loadBeanDefinitions(String... var1) throws BeanDefinitionStoreException;
}

public abstract class AbstractBeanDefinitionReader implements BeanDefinitionReader, EnvironmentCapable {
  protected final Log logger = LogFactory.getLog(this.getClass());
  private final BeanDefinitionRegistry registry;
  @Nullable
  private ResourceLoader resourceLoader;
  @Nullable
  private ClassLoader beanClassLoader;
  private Environment environment;
  private BeanNameGenerator beanNameGenerator = new DefaultBeanNameGenerator();

  protected AbstractBeanDefinitionReader(BeanDefinitionRegistry registry) {
    Assert.notNull(registry, "BeanDefinitionRegistry must not be null");
    this.registry = registry;
    if (this.registry instanceof ResourceLoader) {
      this.resourceLoader = (ResourceLoader)this.registry;
    } else {
      this.resourceLoader = new PathMatchingResourcePatternResolver();
    }

    if (this.registry instanceof EnvironmentCapable) {
      this.environment = ((EnvironmentCapable)this.registry).getEnvironment();
    } else {
      this.environment = new StandardEnvironment();
    }

  }

  public int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException {
    Assert.notNull(resources, "Resource array must not be null");
    int count = 0;
    Resource[] var3 = resources;
    int var4 = resources.length;

    for(int var5 = 0; var5 < var4; ++var5) {
      Resource resource = var3[var5];
      count += this.loadBeanDefinitions((Resource)resource);
    }

    return count;
  }

  public int loadBeanDefinitions(String location) throws BeanDefinitionStoreException {
    return this.loadBeanDefinitions(location, (Set)null);
  }
	//	按照其他的模块的性情，这里应该是 doLoadBeanDefinitions ，其他重载方法就是转换下内容。
  public int loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources) throws BeanDefinitionStoreException {
    ResourceLoader resourceLoader = this.getResourceLoader();
    if (resourceLoader == null) {
      throw new BeanDefinitionStoreException("Cannot load bean definitions from location [" + location + "]: no ResourceLoader available");
    } else {
      int count;
      if (resourceLoader instanceof ResourcePatternResolver) {
        try {
          Resource[] resources = ((ResourcePatternResolver)resourceLoader).getResources(location);
          count = this.loadBeanDefinitions(resources);
          if (actualResources != null) {
            Collections.addAll(actualResources, resources);
          }

          if (this.logger.isTraceEnabled()) {
            this.logger.trace("Loaded " + count + " bean definitions from location pattern [" + location + "]");
          }

          return count;
        } catch (IOException var6) {
          throw new BeanDefinitionStoreException("Could not resolve bean definition resource pattern [" + location + "]", var6);
        }
      } else {
        Resource resource = resourceLoader.getResource(location);
        count = this.loadBeanDefinitions((Resource)resource);
        if (actualResources != null) {
          actualResources.add(resource);
        }

        if (this.logger.isTraceEnabled()) {
          this.logger.trace("Loaded " + count + " bean definitions from location [" + location + "]");
        }

        return count;
      }
    }
  }

  public int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException {
    Assert.notNull(locations, "Location array must not be null");
    int count = 0;
    String[] var3 = locations;
    int var4 = locations.length;

    for(int var5 = 0; var5 < var4; ++var5) {
      String location = var3[var5];
      count += this.loadBeanDefinitions(location);
    }

    return count;
  }
}
```

​     

   + 基于 注解 配置

     就是配置 @Compment、 @Bean 等注解来实现，@Service 和 @Repository 里面有加 @Compment 只是为了让代码分层更清晰而已。

   + 基于 Spring API 配置  

     DefaultListableBeanFactory 实现了 BeanRegistry 接口，其中 registerBeanDefinition 方法就是在配置。

```java
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException {}
```


一般是这个 GenericBeanDefinition 类，不管你是什么类，在我这，都叫 BeanDefinition ，而且在后面会有个 Merge 过程，将所有 BeanDefinition 再次转换成 `RootBeanDefinition` 然后命名为 mbd 进行各种操作。


### Spring Bean 元信息解析阶段

+ 面向资源 BeanDefinition 解析（里面有各种 Load 方法）
  
	+ BeanDefinitionReader
  + XML 解析器 - BeanDefinitionParser
  
+ 面向注解 BeanDefinition 解析
  
	+ AnnotatedBeanDefinitionReader
	  + 资源
	    + 类对象 - java.lang.Class
	  + 底层
	    + 条件评估 - ConditionEvaluator
	    + Bean 范围解析 - ScopeMetadataResolver
	    + BeanDefinition 解析 - 内部 API 实现
	    + BeanDefinition 处理 - AnnotationConfigUtils.processCommonDefinitionAnnotations
	    + BeanDefinition 注册 - BeanDefinitionRegisty

```java
// 这个类没有子类，也不继承 Resource ,就是纯粹的解析注解的 BeanDefitionReader
public class AnnotatedBeanDefinitionReader {
  // 这个的实现有 DefaultListableBeanFactory,AnnotationConfigServletWebApplicationContext等等
  // 这也是个策略模式，通过构造器注入，使用不同 BeanDefinitionRegistry 来注册。
  private final BeanDefinitionRegistry registry;
  // 这里一般是 AnnotationBeanNameGenerator 以类名首字母小写生成 beanName
  private BeanNameGenerator beanNameGenerator;
  // 解析元信息相关的数据，这是个接口，里面就一个方法，方法返回值是ScopeMetadata ，而ScopeMetadata包括 proxy 的一些信息 public enum ScopProxyMode {DEFAULT,NO,INTERFACE,TAGET_CLASS}
  private ScopeMetadataResolver scopeMetadataResolver;
  // 这是做评估的 具体在它的 shouldSkip 方法是不是该跳过当前 Bean 注册与否 
  private ConditionEvaluator conditionEvaluator;

  public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) {
    this(registry, getOrCreateEnvironment(registry));
  }

  public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) {
    this.beanNameGenerator = new AnnotationBeanNameGenerator();
    this.scopeMetadataResolver = new AnnotationScopeMetadataResolver();
    Assert.notNull(registry, "BeanDefinitionRegistry must not be null");
    Assert.notNull(environment, "Environment must not be null");
    this.registry = registry;
    this.conditionEvaluator = new ConditionEvaluator(registry, environment, (ResourceLoader)null);
    AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
  }

  public void register(Class<?>... annotatedClasses) {
    Class[] var2 = annotatedClasses;
    int var3 = annotatedClasses.length;

    for(int var4 = 0; var4 < var3; ++var4) {
      Class<?> annotatedClass = var2[var4];
      this.registerBean(annotatedClass);
    }

  }

  public void registerBean(Class<?> annotatedClass) {
    this.doRegisterBean(annotatedClass, (Supplier)null, (String)null, (Class[])null);
  }
  public <T> void registerBean(Class<T> annotatedClass, @Nullable Supplier<T> instanceSupplier) {
    this.doRegisterBean(annotatedClass, instanceSupplier, (String)null, (Class[])null);
  }

  public <T> void registerBean(Class<T> annotatedClass, String name, @Nullable Supplier<T> instanceSupplier) {
    this.doRegisterBean(annotatedClass, instanceSupplier, name, (Class[])null);
  }

  public void registerBean(Class<?> annotatedClass, Class<? extends Annotation>... qualifiers) {
    this.doRegisterBean(annotatedClass, (Supplier)null, (String)null, qualifiers);
  }

  public void registerBean(Class<?> annotatedClass, String name, Class<? extends Annotation>... qualifiers) {
    this.doRegisterBean(annotatedClass, (Supplier)null, name, qualifiers);
  }
  <T> void doRegisterBean(Class<T> annotatedClass, @Nullable Supplier<T> instanceSupplier, @Nullable String name, @Nullable Class<? extends Annotation>[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) {
    AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);
    if (!this.conditionEvaluator.shouldSkip(abd.getMetadata())) {
      abd.setInstanceSupplier(instanceSupplier);
      ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);
      abd.setScope(scopeMetadata.getScopeName());
      // 	这里命名了，就用你命名的，没命名就生成
      String beanName = name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry);
      AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
      int var10;
      int var11;
      if (qualifiers != null) {
        Class[] var9 = qualifiers;
        var10 = qualifiers.length;

        for(var11 = 0; var11 < var10; ++var11) {
          Class<? extends Annotation> qualifier = var9[var11];
          if (Primary.class == qualifier) {
            abd.setPrimary(true);
          } else if (Lazy.class == qualifier) {
            abd.setLazyInit(true);
          } else {
            abd.addQualifier(new AutowireCandidateQualifier(qualifier));
          }
        }
      }

      BeanDefinitionCustomizer[] var13 = definitionCustomizers;
      var10 = definitionCustomizers.length;

      for(var11 = 0; var11 < var10; ++var11) {
        BeanDefinitionCustomizer customizer = var13[var11];
        customizer.customize(abd);
      }

      BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
      definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
      BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
    }
  }
}
```
这里你都用 Java API 方式配置了，一定有 BeanDefition 配置了。

### Spring Bean 注册阶段

DefaultListableBeanFactory 实现了 BeanDefinitionRegistry 。它还有其他的实现类，关于 XML 、注解、Groovy、Reactive（响应式的，Josh Long 在 19年推特上有置顶 《Reactive Spring》）、还有其他的 GenericApplicationContext。 

```java
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException {
  // 判断参数是否合法
  Assert.hasText(beanName, "Bean name must not be empty");
  Assert.notNull(beanDefinition, "BeanDefinition must not be null");
  // 这里进行一个转换
  if (beanDefinition instanceof AbstractBeanDefinition) {
    try {
      ((AbstractBeanDefinition)beanDefinition).validate();
    } catch (BeanDefinitionValidationException var9) {
      throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, "Validation of bean definition failed", var9);
    }
  }
  // 这里判断是否存在响应的 BeanDefinition 
  //	beanDefinitionMap     
  //private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap(256);

  BeanDefinition existingDefinition = (BeanDefinition)this.beanDefinitionMap.get(beanName);
  if (existingDefinition != null) {
    // Spring Boot 2.1 后有个开关，来看是否能够有相同 BeanDefition 存在，默认为 否
    if (!this.isAllowBeanDefinitionOverriding()) {
      throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);
    }
    // 这里的 Role 默认是 0，在造器中设置为 0
    // 当前bean 定义的角色，初始化为 ROLE_APPLICATION ， 提示这是一个应用bean
    // 另外还有基础设施bean（仅供框架内部工作使用），和 支持bean
    // int ROLE_APPLICATION = 0;
    // int ROLE_SUPPORT = 1;
    // int ROLE_INFRASTRUCTURE = 2;
    if (existingDefinition.getRole() < beanDefinition.getRole()) {
      if (this.logger.isInfoEnabled()) {
        this.logger.info("Overriding user-defined bean definition for bean '" + beanName + "' with a framework-generated bean definition: replacing [" + existingDefinition + "] with [" + beanDefinition + "]");
      }
      // 如果是同一个 BeanDefinition 那自己覆盖自己，没问题，
    } else if (!beanDefinition.equals(existingDefinition)) {
      if (this.logger.isDebugEnabled()) {
        this.logger.debug("Overriding bean definition for bean '" + beanName + "' with a different definition: replacing [" + existingDefinition + "] with [" + beanDefinition + "]");
      }
    } else if (this.logger.isTraceEnabled()) {
      this.logger.trace("Overriding bean definition for bean '" + beanName + "' with an equivalent definition: replacing [" + existingDefinition + "] with [" + beanDefinition + "]");
    }
    // 最终还是放进去了
    this.beanDefinitionMap.put(beanName, beanDefinition);
  } else {
    // 这里表明是不是 BeanFacotory 开始加载了。通常是 false 
    if (this.hasBeanCreationStarted()) {
      // 细化 锁 粒度，针对当前 BeanDefinitionMap 进行一系列非原子操作
      // Cannot modify startup-time collection elements anymore (for stable iteration)
      synchronized(this.beanDefinitionMap) {
        this.beanDefinitionMap.put(beanName, beanDefinition);
        List<String> updatedDefinitions = new ArrayList(this.beanDefinitionNames.size() + 1);
        updatedDefinitions.addAll(this.beanDefinitionNames);
        updatedDefinitions.add(beanName);
        // 这里 BeanDefinitionNames 是一个 ArrayList，是线程不安全的，这里的目的是为了记住 BeanDefinition 的加载顺序。让这里保证 FIFO First In First Out 先进先出
        this.beanDefinitionNames = updatedDefinitions;
        if (this.manualSingletonNames.contains(beanName)) {
          Set<String> updatedSingletons = new LinkedHashSet(this.manualSingletonNames);
          updatedSingletons.remove(beanName);
          this.manualSingletonNames = updatedSingletons;
        }
      }
    } else {
      this.beanDefinitionMap.put(beanName, beanDefinition);
      this.beanDefinitionNames.add(beanName);
      this.manualSingletonNames.remove(beanName);
    }

    this.frozenBeanDefinitionNames = null;
  }

  if (existingDefinition != null || this.containsSingleton(beanName)) {
    this.resetBeanDefinition(beanName);
  }

}
```

### Spring BeanDefinition 合并阶段

+ BeanDefinition 合并
	+ 父子 BeanDefinition 合并
	+ 当前 BeanFactory 查找
	+ 层次性 BeanFactory 查找

```java
public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory {
  //这个方法实际定义在 ConfigurableBeanFactory 中
  @Override 
  public BeanDefinition getMergedBeanDefinition(String name) throws BeansException {
    String beanName = this.transformedBeanName(name);
    //这里通过递归的方式去查找父类
    return (BeanDefinition)(!this.containsBeanDefinition(beanName) && this.getParentBeanFactory() instanceof ConfigurableBeanFactory ? ((ConfigurableBeanFactory)this.getParentBeanFactory()).getMergedBeanDefinition(beanName) : this.getMergedLocalBeanDefinition(beanName));
  }
}
```

一般的 BeanDefinition 是从 GenericBeanDefinition 转换成 RootBeanDefinition。子的 BeanDeifinition 去合并（merge）父的 BeanDefinition 相关配置。

### Spring Bean Class 加载阶段

```java
//在 AbstractBeanFactory 中，执行依赖查找的时候，doGetBean 会执行    
protected <T> T doGetBean(String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException {
  String beanName = this.transformedBeanName(name);
  Object sharedInstance = this.getSingleton(beanName);
  Object bean;
  if (sharedInstance != null && args == null) {
    if (this.logger.isTraceEnabled()) {
      if (this.isSingletonCurrentlyInCreation(beanName)) {
        this.logger.trace("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference");
      } else {
        this.logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
      }
    }

    bean = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);
  } else {
    if (this.isPrototypeCurrentlyInCreation(beanName)) {
      throw new BeanCurrentlyInCreationException(beanName);
    }

    BeanFactory parentBeanFactory = this.getParentBeanFactory();
    // 一般是为空
    if (parentBeanFactory != null && !this.containsBeanDefinition(beanName)) {
      String nameToLookup = this.originalBeanName(name);
      if (parentBeanFactory instanceof AbstractBeanFactory) {
        return ((AbstractBeanFactory)parentBeanFactory).doGetBean(nameToLookup, requiredType, args, typeCheckOnly);
      }

      if (args != null) {
        return parentBeanFactory.getBean(nameToLookup, args);
      }

      if (requiredType != null) {
        return parentBeanFactory.getBean(nameToLookup, requiredType);
      }

      return parentBeanFactory.getBean(nameToLookup);
    }

    if (!typeCheckOnly) {
      this.markBeanAsCreated(beanName);
    }

    try {
      // 这里进行合并，将所有 BeanDefinition 转换为 RootBeanDefinition 进行操作。
      RootBeanDefinition mbd = this.getMergedLocalBeanDefinition(beanName);
      //这里进行检查合并的 BeanDefinition
      this.checkMergedBeanDefinition(mbd, beanName, args);
      // 这里是检查依赖
      String[] dependsOn = mbd.getDependsOn();
      String[] var11;
      if (dependsOn != null) {
        var11 = dependsOn;
        int var12 = dependsOn.length;

        for(int var13 = 0; var13 < var12; ++var13) {
          String dep = var11[var13];
          if (this.isDependent(beanName, dep)) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
          }

          this.registerDependentBean(dep, beanName);

          try {
            this.getBean(dep);
          } catch (NoSuchBeanDefinitionException var24) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "'" + beanName + "' depends on missing bean '" + dep + "'", var24);
          }
        }
      }
      // 没有指定 Scope 默认是 Singleton ，会进这里
      if (mbd.isSingleton()) {
        //  这里的 getSingleton 方法在下面
        // spring-2
        sharedInstance = this.getSingleton(beanName, () -> {
          try {
            // 这里是 Lambda 表达式内容，这里的 createBean 在下面。这个 CreateBean是子类来实现的，具体在下面⬇️ 
            // spring-1 
            return this.createBean(beanName, mbd, args);
          } catch (BeansException var5) {
            this.destroySingleton(beanName);
            throw var5;
          }
        });
        bean = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
      } else if (mbd.isPrototype()) {
        var11 = null;

        Object prototypeInstance;
        try {
          this.beforePrototypeCreation(beanName);
          prototypeInstance = this.createBean(beanName, mbd, args);
        } finally {
          this.afterPrototypeCreation(beanName);
        }

        bean = this.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
      } else {
        String scopeName = mbd.getScope();
        Scope scope = (Scope)this.scopes.get(scopeName);
        if (scope == null) {
          throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
        }

        try {
          Object scopedInstance = scope.get(beanName, () -> {
            this.beforePrototypeCreation(beanName);

            Object var4;
            try {
              var4 = this.createBean(beanName, mbd, args);
            } finally {
              this.afterPrototypeCreation(beanName);
            }

            return var4;
          });
          bean = this.getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
        } catch (IllegalStateException var23) {
          throw new BeanCreationException(beanName, "Scope '" + scopeName + "' is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton", var23);
        }
      }
    } catch (BeansException var26) {
      this.cleanupAfterBeanCreationFailure(beanName);
      throw var26;
    }
  }

  if (requiredType != null && !requiredType.isInstance(bean)) {
    try {
      T convertedBean = this.getTypeConverter().convertIfNecessary(bean, requiredType);
      if (convertedBean == null) {
        throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
      } else {
        return convertedBean;
      }
    } catch (TypeMismatchException var25) {
      if (this.logger.isTraceEnabled()) {
        this.logger.trace("Failed to convert bean '" + name + "' to required type '" + ClassUtils.getQualifiedName(requiredType) + "'", var25);
      }

      throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
    }
  } else {
    return bean;
  }
}
// 获得 SingletonBean
public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {
  Assert.notNull(beanName, "Bean name must not be null");
  // 这里是一个 ConcurentHashMap
  synchronized(this.singletonObjects) {
    Object singletonObject = this.singletonObjects.get(beanName);
    // 在 ObjectFactory 中找到这个 Bean 就直接返回了，下面是为 null 才会才会操作
    if (singletonObject == null) {
      if (this.singletonsCurrentlyInDestruction) {
        throw new BeanCreationNotAllowedException(beanName, "Singleton bean creation not allowed while singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!)");
      }

      if (this.logger.isDebugEnabled()) {
        this.logger.debug("Creating shared instance of singleton bean '" + beanName + "'");
      }

      this.beforeSingletonCreation(beanName);
      boolean newSingleton = false;
      boolean recordSuppressedExceptions = this.suppressedExceptions == null;
      if (recordSuppressedExceptions) {
        this.suppressedExceptions = new LinkedHashSet();
      }

      try {
        // 没有找到会在这里进行 getObject，这里是没有实现的，具体的在上面的 Lambda 表达式中有。往上翻⬆️
        // 上面采用匿名类实现 SingletonFactory 
        // spring-2
        singletonObject = singletonFactory.getObject();
        newSingleton = true;
      } catch (IllegalStateException var16) {
        singletonObject = this.singletonObjects.get(beanName);
        if (singletonObject == null) {
          throw var16;
        }
      } catch (BeanCreationException var17) {
        BeanCreationException ex = var17;
        if (recordSuppressedExceptions) {
          Iterator var8 = this.suppressedExceptions.iterator();

          while(var8.hasNext()) {
            Exception suppressedException = (Exception)var8.next();
            ex.addRelatedCause(suppressedException);
          }
        }

        throw ex;
      } finally {
        if (recordSuppressedExceptions) {
          this.suppressedExceptions = null;
        }

        this.afterSingletonCreation(beanName);
      }

      if (newSingleton) {
        this.addSingleton(beanName, singletonObject);
      }
    }

    return singletonObject;
  }
}
//这个是 AbstractBeanFactory 的子类进行实现的。具体的类名称，叫AbstractAutowireCapableBeanFactory
// spring-1 
protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
  if (this.logger.isTraceEnabled()) {
    this.logger.trace("Creating instance of bean '" + beanName + "'");
  }

  RootBeanDefinition mbdToUse = mbd;
  // 这里的 resolveBeanClass 
  Class<?> resolvedClass = this.resolveBeanClass(mbd, beanName, new Class[0]);
  if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
    mbdToUse = new RootBeanDefinition(mbd);
    mbdToUse.setBeanClass(resolvedClass);
  }

  try {
    mbdToUse.prepareMethodOverrides();
  } catch (BeanDefinitionValidationException var9) {
    throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, "Validation of method overrides failed", var9);
  }

  Object beanInstance;
  try {
    beanInstance = this.resolveBeforeInstantiation(beanName, mbdToUse);
    if (beanInstance != null) {
      return beanInstance;
    }
  } catch (Throwable var10) {
    throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "BeanPostProcessor before instantiation of bean failed", var10);
  }

  try {
    // 这里的 doCreateBean 在下面实例化 Bean 中有讲解 ⬇️
    // spring-3
    beanInstance = this.doCreateBean(beanName, mbdToUse, args);
    if (this.logger.isTraceEnabled()) {
      this.logger.trace("Finished creating instance of bean '" + beanName + "'");
    }

    return beanInstance;
  } catch (ImplicitlyAppearedSingletonException | BeanCreationException var7) {
    throw var7;
  } catch (Throwable var8) {
    throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "Unexpected exception during bean creation", var8);
  }
}
//这里就是在 RootBeanDefinition 进行 getBeanClass 操作
@Nullable
protected Class<?> resolveBeanClass(RootBeanDefinition mbd, String beanName, Class<?>... typesToMatch) throws CannotLoadBeanClassException {
  try {
    // 判断当前是否有 BeanClass
    if (mbd.hasBeanClass()) {
      return mbd.getBeanClass();
    } else {
      // 这里判断 Java 安全方面内容有没有激活，如果激活了，就不等于空，那就以安全的方式来resolveBeanClass
      return System.getSecurityManager() != null ? (Class)AccessController.doPrivileged(() -> {
        //这里来 resovleBeanClass 具体内容看下面⬇️第六步
        // spring-4
        return this.doResolveBeanClass(mbd, typesToMatch);
      }, this.getAccessControlContext()) : this.doResolveBeanClass(mbd, typesToMatch);
    }
  } catch (PrivilegedActionException var6) {
    ClassNotFoundException ex = (ClassNotFoundException)var6.getException();
    throw new CannotLoadBeanClassException(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), ex);
  } catch (ClassNotFoundException var7) {
    throw new CannotLoadBeanClassException(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), var7);
  } catch (LinkageError var8) {
    throw new CannotLoadBeanClassException(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), var8);
  }
}
// 这里来 doResovleBeanClass
// spring-4
private Class<?> doResolveBeanClass(RootBeanDefinition mbd, Class<?>... typesToMatch) throws ClassNotFoundException {
  // 这里有两个 ClassLoader，一个是当前 BeanFactory 的 ClassLoader ，默认是 AppClassloader
  ClassLoader beanClassLoader = this.getBeanClassLoader();
  // 这是一个 dynamicClassLoader
  ClassLoader dynamicLoader = beanClassLoader;
  boolean freshResolve = false;
  // 一般这里都不会激活 start
  if (!ObjectUtils.isEmpty(typesToMatch)) {
    ClassLoader tempClassLoader = this.getTempClassLoader();
    if (tempClassLoader != null) {
      dynamicLoader = tempClassLoader;
      freshResolve = true;
      if (tempClassLoader instanceof DecoratingClassLoader) {
        DecoratingClassLoader dcl = (DecoratingClassLoader)tempClassLoader;
        Class[] var8 = typesToMatch;
        int var9 = typesToMatch.length;

        for(int var10 = 0; var10 < var9; ++var10) {
          Class<?> typeToMatch = var8[var10];
          dcl.excludeClass(typeToMatch.getName());
        }
      }
    }
  }
  // 一般这里都不会激活 end
  //这里获取 BeanClassName
  String className = mbd.getBeanClassName();
  if (className != null) {
    // 这里评估一下 BeanClass，有时候 BeanClass 的名称和这个名称是不一样的
    Object evaluated = this.evaluateBeanDefinitionString(className, mbd);
    if (!className.equals(evaluated)) {
      if (evaluated instanceof Class) {
        return (Class)evaluated;
      }

      if (!(evaluated instanceof String)) {
        throw new IllegalStateException("Invalid class name expression result: " + evaluated);
      }

      className = (String)evaluated;
      freshResolve = true;
    }
    // 这里一般也是 false，不会走这里
    if (freshResolve) {
      if (dynamicLoader != null) {
        try {
          return dynamicLoader.loadClass(className);
        } catch (ClassNotFoundException var12) {
          if (this.logger.isTraceEnabled()) {
            this.logger.trace("Could not load class [" + className + "] from " + dynamicLoader + ": " + var12);
          }
        }
      }
      // 和这里一样
      return ClassUtils.forName(className, dynamicLoader);
    }
  }
  // 这里才是关键
  return mbd.resolveBeanClass(beanClassLoader);
}
// 这个是 AbstractBeanDefinition 中的方法，这里利用反射来加载 Bean
@Nullable
public Class<?> resolveBeanClass(@Nullable ClassLoader classLoader) throws ClassNotFoundException {
  String className = this.getBeanClassName();
  if (className == null) {
    return null;
  } else {
    Class<?> resolvedClass = ClassUtils.forName(className, classLoader);
    this.beanClass = resolvedClass;
    return resolvedClass;
  }
}
```

至此 BeanDefinition 变成 Class 的操作已经结束。一般情况下，就是利用 加载 BeanFactory  的ClassLoader来加载，只是多了个 Java 安全的校验加载。

### Spring Bean 实例化前阶段

主要是下面这个接口，在Spring 5前面有个Adpter类，就是和 WebMvcConfigurerAdapter 一样，为了适配之后的类。继承这个接口，实现 postProcessBeforeInstantiation 方法，就可以对 Bean 实例化前进行操作

```java
public interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor {
  @Nullable
  default Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException {
    //这里可以返回一个代理对象，为 null 就是不做改变，具体在
    return null;
  }
  // 如果上面返回对象不为空，那么马上就会执行这一步操作，为空，则在 population 中执行。属性填充后执行
  default boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException {
    return true;
  }

  @Nullable
  default PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException {
    return null;
  }

  /** @deprecated */
  @Deprecated
  @Nullable
  default PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException {
    return pvs;
  }
}

//AbstractAutowireCapableBeanFactory
// 这里创建 Bean
protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
  if (this.logger.isTraceEnabled()) {
    this.logger.trace("Creating instance of bean '" + beanName + "'");
  }

  RootBeanDefinition mbdToUse = mbd;
  // 这个就是上面的 BeanDefinition 转换为 Class 的调用
  Class<?> resolvedClass = this.resolveBeanClass(mbd, beanName, new Class[0]);
  if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
    mbdToUse = new RootBeanDefinition(mbd);
    mbdToUse.setBeanClass(resolvedClass);
  }

  try {
    mbdToUse.prepareMethodOverrides();
  } catch (BeanDefinitionValidationException var9) {
    throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, "Validation of method overrides failed", var9);
  }

  Object beanInstance;
  try {
    // 这里进行 Bean 的前置处理，具体方法实现内容    如下⬇️
    // 对应上面的 postProcessBeforeInstantiation 方法，如果返回了对象，则直接跳过下面的 doCreateBean 方法。
    // spring-5
    beanInstance = this.resolveBeforeInstantiation(beanName, mbdToUse);
    // 就是这里对 Bean 进行了判断，如果实例化前就把这个 Bean 给返回了，那就不用执行下面的操作le
    if (beanInstance != null) {
      return beanInstance;
    }
  } catch (Throwable var10) {
    throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "BeanPostProcessor before instantiation of bean failed", var10);
  }

  try {
    beanInstance = this.doCreateBean(beanName, mbdToUse, args);
    if (this.logger.isTraceEnabled()) {
      this.logger.trace("Finished creating instance of bean '" + beanName + "'");
    }

    return beanInstance;
  } catch (ImplicitlyAppearedSingletonException | BeanCreationException var7) {
    throw var7;
  } catch (Throwable var8) {
    throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "Unexpected exception during bean creation", var8);
  }
}
// AbstractAutowireCapableBeanFactory
// spring-5
@Nullable
protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {
  Object bean = null;
  if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {
    if (!mbd.isSynthetic() && this.hasInstantiationAwareBeanPostProcessors()) {
      //目标类型  
      Class<?> targetType = this.determineTargetType(beanName, mbd);
      // 这里就是判断，执行前置操作 applyBeanPostProcessorsBeforeInstantiation 这里面的内容其实就是 获得 BeanPostProcessor 然后遍历出 InstantiationAwareBeanPostProcessor 执行 postProcessBeforeInstantiation 方法。这里可以来个狸猫换太子，用代理对象替换 Bean
      if (targetType != null) {
        bean = this.applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);
        // 如果这里的 Bean 不为空，马上执行 后置操作 postProcessAfterInitialization#postProcessAfterInitialization()
        if (bean != null) {
          bean = this.applyBeanPostProcessorsAfterInitialization(bean, beanName);
        }
      }
    }

    mbd.beforeInstantiationResolved = bean != null;
  }

  return bean;
}

// AbstractAutowireCapableBeanFactory
// spring-3
protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
  BeanWrapper instanceWrapper = null;
  if (mbd.isSingleton()) {
    instanceWrapper = (BeanWrapper)this.factoryBeanInstanceCache.remove(beanName);
  }

  if (instanceWrapper == null) {
    instanceWrapper = this.createBeanInstance(beanName, mbd, args);
  }

  Object bean = instanceWrapper.getWrappedInstance();
  Class<?> beanType = instanceWrapper.getWrappedClass();
  if (beanType != NullBean.class) {
    mbd.resolvedTargetType = beanType;
  }

  synchronized(mbd.postProcessingLock) {
    if (!mbd.postProcessed) {
      try {
        // 合并 BeanDefinition 前置操作
        this.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
      } catch (Throwable var17) {
        throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Post-processing of merged bean definition failed", var17);
      }

      mbd.postProcessed = true;
    }
  }
  // 这里检查循环依赖
  boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
  if (earlySingletonExposure) {
    if (this.logger.isTraceEnabled()) {
      this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
    }

    this.addSingletonFactory(beanName, () -> {
      return this.getEarlyBeanReference(beanName, mbd, bean);
    });
  }

  Object exposedObject = bean;

  try {
    // 这里执行 属性填充 功能，具体代码在下面
    this.populateBean(beanName, mbd, instanceWrapper);
    // 这里是初始化 Bean ，初始化 Bean 才执行 postProcessBeforeInstantiation 这个操作，具体的在下面 ⬇️
    // spring-6
    exposedObject = this.initializeBean(beanName, exposedObject, mbd);
  } catch (Throwable var18) {
    if (var18 instanceof BeanCreationException && beanName.equals(((BeanCreationException)var18).getBeanName())) {
      throw (BeanCreationException)var18;
    }

    throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Initialization of bean failed", var18);
  }

  if (earlySingletonExposure) {
    Object earlySingletonReference = this.getSingleton(beanName, false);
    if (earlySingletonReference != null) {
      if (exposedObject == bean) {
        exposedObject = earlySingletonReference;
      } else if (!this.allowRawInjectionDespiteWrapping && this.hasDependentBean(beanName)) {
        String[] dependentBeans = this.getDependentBeans(beanName);
        Set<String> actualDependentBeans = new LinkedHashSet(dependentBeans.length);
        String[] var12 = dependentBeans;
        int var13 = dependentBeans.length;

        for(int var14 = 0; var14 < var13; ++var14) {
          String dependentBean = var12[var14];
          if (!this.removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
            actualDependentBeans.add(dependentBean);
          }
        }

        if (!actualDependentBeans.isEmpty()) {
          throw new BeanCurrentlyInCreationException(beanName, "Bean with name '" + beanName + "' has been injected into other beans [" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + "] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using 'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.");
        }
      }
    }
  }

  try {
    this.registerDisposableBeanIfNecessary(beanName, bean, mbd);
    return exposedObject;
  } catch (BeanDefinitionValidationException var16) {
    throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Invalid destruction signature", var16);
  }
}
// AbstractAutowireCapableBeanFactory
protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
  if (bw == null) {
    if (mbd.hasPropertyValues()) {
      throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Cannot apply property values to null instance");
    }
    // 老版本的 Spring 中，是有个 else{return;}的，不过是多此一举，下面的 esle 包裹到了方法结束
  } else {
    boolean continueWithPropertyPopulation = true;
    if (!mbd.isSynthetic() && this.hasInstantiationAwareBeanPostProcessors()) {
      Iterator var5 = this.getBeanPostProcessors().iterator();

      while(var5.hasNext()) {
        BeanPostProcessor bp = (BeanPostProcessor)var5.next();
        // 这里就是 Bean 实例化前的操作，执行 postProcessAfterInstantiation 方法
        if (bp instanceof InstantiationAwareBeanPostProcessor) {
          InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp;
          // 返回值为是否继续填充 Bean
          if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
            continueWithPropertyPopulation = false;
            break;
          }
        }
      }
    }
    //如果后处理器继续填充，则执行下面代码，原来这里是 if(!continueWithPropertyPopulation){return;}
    if (continueWithPropertyPopulation) {
      PropertyValues pvs = mbd.hasPropertyValues() ? mbd.getPropertyValues() : null;
      if (mbd.getResolvedAutowireMode() == 1 || mbd.getResolvedAutowireMode() == 2) {
        MutablePropertyValues newPvs = new MutablePropertyValues((PropertyValues)pvs);
        //这里以前是 == RootBeanDefinition.AUTOWIRE_BY_NAME，这种硬编码的方式，这就是魔法值了。要被 alibaba 编码规范插件检测出来的。
        if (mbd.getResolvedAutowireMode() == 1) {
          //根据名称自动注入
          this.autowireByName(beanName, mbd, bw, newPvs);
        }
        // 同上
        if (mbd.getResolvedAutowireMode() == 2) {
          //根据类型自动注入
          this.autowireByType(beanName, mbd, bw, newPvs);
        }

        pvs = newPvs;
      }

      boolean hasInstAwareBpps = this.hasInstantiationAwareBeanPostProcessors();
      boolean needsDepCheck = mbd.getDependencyCheck() != 0;
      PropertyDescriptor[] filteredPds = null;
      if (hasInstAwareBpps) {
        if (pvs == null) {
          pvs = mbd.getPropertyValues();
        }

        Iterator var9 = this.getBeanPostProcessors().iterator();

        while(var9.hasNext()) {
          BeanPostProcessor bp = (BeanPostProcessor)var9.next();
          if (bp instanceof InstantiationAwareBeanPostProcessor) {
            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp;
            PropertyValues pvsToUse = ibp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);
            if (pvsToUse == null) {
              if (filteredPds == null) {
                filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
              }

              pvsToUse = ibp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);
              if (pvsToUse == null) {
                return;
              }
            }

            pvs = pvsToUse;
          }
        }
      }

      if (needsDepCheck) {
        if (filteredPds == null) {
          filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
        }

        this.checkDependencies(beanName, mbd, filteredPds, (PropertyValues)pvs);
      }

      if (pvs != null) {
        this.applyPropertyValues(beanName, mbd, bw, (PropertyValues)pvs);
      }

    }
  }
}

//AbstractAutowireCapableBeanFactory
// spring-6
protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {
  if (System.getSecurityManager() != null) {
    AccessController.doPrivileged(() -> {
      this.invokeAwareMethods(beanName, bean);
      return null;
    }, this.getAccessControlContext());
  } else {
    // 这个方法在下面，就是执行各种 Aware 接口 ⬇️
    // spring-7
    this.invokeAwareMethods(beanName, bean);
  }

  Object wrappedBean = bean;
  if (mbd == null || !mbd.isSynthetic()) {
    wrappedBean = this.applyBeanPostProcessorsBeforeInitialization(bean, beanName);
  }

  try {
    this.invokeInitMethods(beanName, wrappedBean, mbd);
  } catch (Throwable var6) {
    throw new BeanCreationException(mbd != null ? mbd.getResourceDescription() : null, beanName, "Invocation of init method failed", var6);
  }

  if (mbd == null || !mbd.isSynthetic()) {
    wrappedBean = this.applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
  }

  return wrappedBean;
}
//AbstractAutowireCapableBeanFactory
// spring-7
private void invokeAwareMethods(String beanName, Object bean) {
  if (bean instanceof Aware) {
    if (bean instanceof BeanNameAware) {
      ((BeanNameAware)bean).setBeanName(beanName);
    }

    if (bean instanceof BeanClassLoaderAware) {
      ClassLoader bcl = this.getBeanClassLoader();
      if (bcl != null) {
        ((BeanClassLoaderAware)bean).setBeanClassLoader(bcl);
      }
    }

    if (bean instanceof BeanFactoryAware) {
      ((BeanFactoryAware)bean).setBeanFactory(this);
    }
  }

}
```
### Spring Bean 实例化阶段

+ 传统实例化方式
  + 实例化策略 - InstantiationStrategy
  + 构造器依赖注入（这里的一个方法有几百行代码，去验证，加载，如果参数比较多，不建议构造器注入）

实例化就是上面的 doCreateBean 方法。

```java
     // AbstractAutowireCapableBeanFactory
     protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
       // 这里引入一个 Wrapper 一个 Bean 实例的包装，可以做很多事
       BeanWrapper instanceWrapper = null;
       if (mbd.isSingleton()) {
         //    private final ConcurrentMap<String, BeanWrapper> factoryBeanInstanceCache;
     
         instanceWrapper = (BeanWrapper)this.factoryBeanInstanceCache.remove(beanName);
       }
       // 如果 这个 wrapper 为空，就去创建，一般会进这里
       if (instanceWrapper == null) {
         // 这个 createBeanInstance 方法在下面 ⬇️
         // spring-8
         instanceWrapper = this.createBeanInstance(beanName, mbd, args);
       }
     
       Object bean = instanceWrapper.getWrappedInstance();
       Class<?> beanType = instanceWrapper.getWrappedClass();
       if (beanType != NullBean.class) {
         mbd.resolvedTargetType = beanType;
       }
     
       synchronized(mbd.postProcessingLock) {
         if (!mbd.postProcessed) {
           try {
             // 合并 BeanDefinition 前置操作
             this.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
           } catch (Throwable var17) {
             throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Post-processing of merged bean definition failed", var17);
           }
     
           mbd.postProcessed = true;
         }
       }
       // 这里检查循环依赖
       boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
       if (earlySingletonExposure) {
         if (this.logger.isTraceEnabled()) {
           this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
         }
     
         this.addSingletonFactory(beanName, () -> {
           return this.getEarlyBeanReference(beanName, mbd, bean);
         });
       }
     
       Object exposedObject = bean;
     
       try {
         // 这里执行 属性填充 功能，具体代码在下面
         this.populateBean(beanName, mbd, instanceWrapper);
         // 这里是初始化 Bean ，初始化 Bean 才执行 postProcessBeforeInstantiation 这个操作，具体的在下面 ⬇️
         // spring-6
         exposedObject = this.initializeBean(beanName, exposedObject, mbd);
       } catch (Throwable var18) {
         if (var18 instanceof BeanCreationException && beanName.equals(((BeanCreationException)var18).getBeanName())) {
           throw (BeanCreationException)var18;
         }
     
         throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Initialization of bean failed", var18);
       }
     
       if (earlySingletonExposure) {
         Object earlySingletonReference = this.getSingleton(beanName, false);
         if (earlySingletonReference != null) {
           if (exposedObject == bean) {
             exposedObject = earlySingletonReference;
           } else if (!this.allowRawInjectionDespiteWrapping && this.hasDependentBean(beanName)) {
             String[] dependentBeans = this.getDependentBeans(beanName);
             Set<String> actualDependentBeans = new LinkedHashSet(dependentBeans.length);
             String[] var12 = dependentBeans;
             int var13 = dependentBeans.length;
     
             for(int var14 = 0; var14 < var13; ++var14) {
               String dependentBean = var12[var14];
               if (!this.removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                 actualDependentBeans.add(dependentBean);
               }
             }
     
             if (!actualDependentBeans.isEmpty()) {
               throw new BeanCurrentlyInCreationException(beanName, "Bean with name '" + beanName + "' has been injected into other beans [" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + "] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using 'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.");
             }
           }
         }
       }
     
       try {
         this.registerDisposableBeanIfNecessary(beanName, bean, mbd);
         return exposedObject;
       } catch (BeanDefinitionValidationException var16) {
         throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Invalid destruction signature", var16);
       }
     }
     
     
     //AbstractAutowireCapableBeanFactory
     // spring-8
     protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
       // 这里的 resovleBeanClass 就是上面提到的 BeanClass 加载，
       Class<?> beanClass = this.resolveBeanClass(mbd, beanName, new Class[0]);
       if (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) {
         throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Bean class isn't public, and non-public access not allowed: " + beanClass.getName());
       } else {
         // 这是一个函数式接口，在 Spring5 之前不支持这个，一般用 @Compment 来声明的，是为 null
         Supplier<?> instanceSupplier = mbd.getInstanceSupplier();
         if (instanceSupplier != null) {
           return this.obtainFromSupplier(instanceSupplier, beanName);
         } else if (mbd.getFactoryMethodName() != null) {
           // 这个也一般不会执行，根据 BeanFactoryName 去获取 BeanWrapper
           return this.instantiateUsingFactoryMethod(beanName, mbd, args);
         } else {
           //	 更多的是执行这个,resoled 判断对象是否被处理过
           boolean resolved = false;
           boolean autowireNecessary = false;
           if (args == null) {
             synchronized(mbd.constructorArgumentLock) {
               // spring-11
               if (mbd.resolvedConstructorOrFactoryMethod != null) {
                 resolved = true;
                 autowireNecessary = mbd.constructorArgumentsResolved;
               }
             }
           }
     //一般这里是不满足的
           if (resolved) {
             return autowireNecessary ? this.autowireConstructor(beanName, mbd, (Constructor[])null, (Object[])null) : this.instantiateBean(beanName, mbd);
           } else {
             // 	一般这里不满足，直接跳过
             // spring-10
             Constructor<?>[] ctors = this.determineConstructorsFromBeanPostProcessors(beanClass, beanName);
             if (ctors == null && mbd.getResolvedAutowireMode() != 3 && !mbd.hasConstructorArgumentValues() && ObjectUtils.isEmpty(args)) {
               //这里通常来说是null
               ctors = mbd.getPreferredConstructors();
               // 这个 instantiaeaBean 调用无参构造器 方法如下
               // 之前的代码是 if(ctors!=null){return autowireConstructor(beanName, mbd, ctors, (Object[])null)}
               return ctors != null ? this.autowireConstructor(beanName, mbd, ctors, (Object[])null) : this.instantiateBean(beanName, mbd);
             } else {
               // 这边是根据有参构造器 注入
               // 一般情况下的 Bean 走的这个方法，不做特殊处理
               return this.autowireConstructor(beanName, mbd, ctors, args);
             }
           }
         }
       }
     }
     
     //AbstractAutowireCapableBeanFactory
      protected BeanWrapper instantiateBean(String beanName, RootBeanDefinition mbd) {
             try {
                 Object beanInstance;
                 if (System.getSecurityManager() != null) {
                     beanInstance = AccessController.doPrivileged(() -> {
                       // instantiate(mbd, beanName, this) 这个方法是重点
                         return thisx.getInstantiationStrategy().instantiate(mbd, beanName, this);
                     }, this.getAccessControlContext());
                 } else {
                   //	这里就是 通过传统的方式，InstantiationStrategy 默认是CglibSubclassingInstantiationStrategy 这里							//  就清楚了，默认采用 Cglib 方法代理生成 Bean。在无参构造器方法中有写。然后这个 instantiate 方法是										// SimpleInstantiationStrategy 类的，具体方法如下⬇️
                   // spring-9
                     beanInstance = this.getInstantiationStrategy().instantiate(mbd, beanName, this);
                 }
     
                 BeanWrapper bw = new BeanWrapperImpl(beanInstance);
                 this.initBeanWrapper(bw);
                 return bw;
             } catch (Throwable var6) {
                 throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Instantiation of bean failed", var6);
             }
         }
     //AbstractAutowireCapableBeanFactory
         public AbstractAutowireCapableBeanFactory() {
             this.instantiationStrategy = new CglibSubclassingInstantiationStrategy();
             this.parameterNameDiscoverer = new DefaultParameterNameDiscoverer();
             this.allowCircularReferences = true;
             this.allowRawInjectionDespiteWrapping = false;
             this.ignoredDependencyTypes = new HashSet();
             this.ignoredDependencyInterfaces = new HashSet();
             this.currentlyCreatedBean = new NamedThreadLocal("Currently created bean");
             this.factoryBeanInstanceCache = new ConcurrentHashMap();
             this.factoryMethodCandidateCache = new ConcurrentHashMap();
             this.filteredPropertyDescriptorsCache = new ConcurrentHashMap();
             this.ignoreDependencyInterface(BeanNameAware.class);
             this.ignoreDependencyInterface(BeanFactoryAware.class);
             this.ignoreDependencyInterface(BeanClassLoaderAware.class);
         }
     
     //SimpleInstantiationStrategy
     // spring-9
     public Object (RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {
       		//	这里判断是否方法覆盖
             if (!bd.hasMethodOverrides()) {
                 Constructor constructorToUse;
                 synchronized(bd.constructorArgumentLock) {
                   // 这里看是否已经处理掉 构造器或者工厂方法
                     constructorToUse = (Constructor)bd.resolvedConstructorOrFactoryMethod;
                     if (constructorToUse == null) {
                       //然后进这个方法
                         Class<?> clazz = bd.getBeanClass();
                       // 这里判断，是否是个接口，是接口直接报错，抛出异常。当然 JPA/MyBatis plus 类似处理注解 AutowiredAnnotationBeanPostProcessor 
                       // implements BeanPostProcessor, BeanFactoryAware 实现这两个接口，然后做 Bean 前置处理，将接口语义转换成实体类，或者用JDK/Cglib做提升，生成代理类
                         if (clazz.isInterface()) {
                             throw new BeanInstantiationException(clazz, "Specified class is an interface");
                         }
     
                         try {
                           // 这里又要和安全相关的，因为这里要调用反射
                             if (System.getSecurityManager() != null) {
                                 clazz.getClass();
                                 constructorToUse = (Constructor)AccessController.doPrivileged(() -> {
                                     return clazz.getDeclaredConstructor();
                                 });
                             } else {
                               // 这里得到默认的无参构造器
                                 constructorToUse = clazz.getDeclaredConstructor();
                             }
     										//  resolvedConstructorOrFactoryMethod 这个就不为空了，对应前面的
                           // spring-11
                             bd.resolvedConstructorOrFactoryMethod = constructorToUse;
                         } catch (Throwable var9) {
                             throw new BeanInstantiationException(clazz, "No default constructor found", var9);
                         }
                     }
                 }
     			//	这里面就是 利用反射创建，newInstance，默认的无参构造器
               // 这个阶段，还没有完成属性的 创建和初始化。
                 return BeanUtils.instantiateClass(constructorToUse, new Object[0]);
             } else {
               //
                 return this.instantiateWithMethodInjection(bd, beanName, owner);
             }
         }
     // spring-10
     @Nullable
protected Constructor<?>[] determineConstructorsFromBeanPostProcessors(@Nullable Class<?> beanClass, String beanName) throws BeansException {
             if (beanClass != null && this.hasInstantiationAwareBeanPostProcessors()) {
                 Iterator var3 = this.getBeanPostProcessors().iterator();
     
                 while(var3.hasNext()) {
                     BeanPostProcessor bp = (BeanPostProcessor)var3.next();
                     if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
                         SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor)bp;
                       // 实现一种拦截机制，来取调用哪种构造器
                         Constructor<?>[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);
                         if (ctors != null) {
                             return ctors;
                         }
                     }
                 }
             }
     
     return null;
}
     
```

构造器注入，是按照类型注入。也可以通过 @Qualifier指定

### Spring Bean 实例化后阶段
```java
// InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation
//判断当前 Bean 是不是要属性填入，如果是，则返回 true，如果不是返回 false。也就是这里可以做一个拦截。具体代码如下
//属性填充阶段后，再去操作，populateBean 方法
  
// AbstractAutowireCapableBeanFactory
// 该方法是 对 Bean 进行属性填充。
protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
  if (bw == null) {
    if (mbd.hasPropertyValues()) {
      throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Cannot apply property values to null instance");
    }
    // 老版本的 Spring 中，是有个 else{return;}的，不过是多此一举，下面的 esle 包裹到了方法结束
  } else {
    boolean continueWithPropertyPopulation = true;
    if (!mbd.isSynthetic() && this.hasInstantiationAwareBeanPostProcessors()) {
      Iterator var5 = this.getBeanPostProcessors().iterator();

      while(var5.hasNext()) {
        BeanPostProcessor bp = (BeanPostProcessor)var5.next();
        // 这里就是 Bean 实例化前的操作，执行 postProcessAfterInstantiation 方法
        if (bp instanceof InstantiationAwareBeanPostProcessor) {
          InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp;
          // 返回值为是否继续填充 Bean，如果为 false，则取反，执行 if 里面的操作。就会跳过后面的属性填充。
          if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
            // 这里为 false ，下面的 if 方法不会执行。
            continueWithPropertyPopulation = false;
            break;
          }
        }
      }
    }
    //如果后处理器继续填充，则执行下面代码，原来这里是 if(!continueWithPropertyPopulation){return;}
    if (continueWithPropertyPopulation) {
      PropertyValues pvs = mbd.hasPropertyValues() ? mbd.getPropertyValues() : null;
      if (mbd.getResolvedAutowireMode() == 1 || mbd.getResolvedAutowireMode() == 2) {
        MutablePropertyValues newPvs = new MutablePropertyValues((PropertyValues)pvs);
        //这里以前是 == RootBeanDefinition.AUTOWIRE_BY_NAME，这种硬编码的方式，这就是魔法值了。要被 alibaba 编码规范插件检测出来的。
        if (mbd.getResolvedAutowireMode() == 1) {
          //根据名称自动注入
          this.autowireByName(beanName, mbd, bw, newPvs);
        }
        // 同上
        if (mbd.getResolvedAutowireMode() == 2) {
          //根据类型自动注入
          this.autowireByType(beanName, mbd, bw, newPvs);
        }

        pvs = newPvs;
      }

      boolean hasInstAwareBpps = this.hasInstantiationAwareBeanPostProcessors();
      boolean needsDepCheck = mbd.getDependencyCheck() != 0;
      PropertyDescriptor[] filteredPds = null;
      if (hasInstAwareBpps) {
        if (pvs == null) {
          pvs = mbd.getPropertyValues();
        }

        Iterator var9 = this.getBeanPostProcessors().iterator();

        while(var9.hasNext()) {
          BeanPostProcessor bp = (BeanPostProcessor)var9.next();
          if (bp instanceof InstantiationAwareBeanPostProcessor) {
            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp;
            PropertyValues pvsToUse = ibp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);
            if (pvsToUse == null) {
              if (filteredPds == null) {
                filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
              }

              pvsToUse = ibp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);
              if (pvsToUse == null) {
                return;
              }
            }

            pvs = pvsToUse;
          }
        }
      }

      if (needsDepCheck) {
        if (filteredPds == null) {
          filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
        }

        this.checkDependencies(beanName, mbd, filteredPds, (PropertyValues)pvs);
      }

      if (pvs != null) {
        this.applyPropertyValues(beanName, mbd, bw, (PropertyValues)pvs);
      }

    }
  }
}
// 2
// 其实在 AbstractAutowiredCapableBeanFactory 中，如果在 doCreateBean 执行之前，就已经返回了 Bean 实例，那么 
// doCreateBean 是不会执行的，为保证 postProcessAfterInstantiation 在 Bean 实例化后一定执行，下面的代码就展示了如何实现的
// AbstractAutowireCapableBeanFactory
// spring-12
@Nullable
protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {
  Object bean = null;
  if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {
    if (!mbd.isSynthetic() && this.hasInstantiationAwareBeanPostProcessors()) {
      Class<?> targetType = this.determineTargetType(beanName, mbd);
      if (targetType != null) {
        // 在这个方法
        bean = this.applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);
        if (bean != null) {
          bean = this.applyBeanPostProcessorsAfterInitialization(bean, beanName);
        }
      }
    }

    mbd.beforeInstantiationResolved = bean != null;
  }

  return bean;
}
// 1 
// AbstractAutowireCapableBeanFactory
// 创建 Bean
protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace("Creating instance of bean '" + beanName + "'");
        }

        RootBeanDefinition mbdToUse = mbd;
        Class<?> resolvedClass = this.resolveBeanClass(mbd, beanName, new Class[0]);
        if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
            mbdToUse = new RootBeanDefinition(mbd);
            mbdToUse.setBeanClass(resolvedClass);
        }

        try {
            mbdToUse.prepareMethodOverrides();
        } catch (BeanDefinitionValidationException var9) {
            throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, "Validation of method overrides failed", var9);
        }

        Object beanInstance;
        try {
          	// spring-12
          	// 这里是解析实例化前，如果有 Bean 实例，就直接返回，跳过下面的 doCreateBean 方法。
            beanInstance = this.resolveBeforeInstantiation(beanName, mbdToUse);
            if (beanInstance != null) {
                return beanInstance;
            }
        } catch (Throwable var10) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "BeanPostProcessor before instantiation of bean failed", var10);
        }

        try {
            beanInstance = this.doCreateBean(beanName, mbdToUse, args);
            if (this.logger.isTraceEnabled()) {
                this.logger.trace("Finished creating instance of bean '" + beanName + "'");
            }

            return beanInstance;
        } catch (ImplicitlyAppearedSingletonException | BeanCreationException var7) {
            throw var7;
        } catch (Throwable var8) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "Unexpected exception during bean creation", var8);
        }
    }

	// 3 
    @Nullable
protected Object applyBeanPostProcessorsBeforeInstantiation(Class<?> beanClass, String beanName) {
  Iterator var3 = this.getBeanPostProcessors().iterator();

  while(var3.hasNext()) {
    BeanPostProcessor bp = (BeanPostProcessor)var3.next();
    if (bp instanceof InstantiationAwareBeanPostProcessor) {
      InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp;
      Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);
      if (result != null) {
        return result;
      }
    }
  }

  return null;
}
//4
public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) throws BeansException {
  Object result = existingBean;

  Object current;
  for(Iterator var4 = this.getBeanPostProcessors().iterator(); var4.hasNext(); result = current) {
    BeanPostProcessor processor = (BeanPostProcessor)var4.next();
    current = processor.postProcessAfterInitialization(result, beanName);
    if (current == null) {
      return result;
    }
  }

  return result;
}
```

也就是为保证 postProcessAfterInitialization 方法`一定`执行，其实有两处互斥的地方调用了该方法。

### Spring Bean 属性赋值前阶段

populateBean 就是属性赋值阶段

```java
// AbstractAutowireCapableBeanFactory
protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
  if (bw == null) {
    if (mbd.hasPropertyValues()) {
      throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Cannot apply property values to null instance");
    }
    // 老版本的 Spring 中，是有个 else{return;}的，不过是多此一举，下面的 esle 包裹到了方法结束
  } else {
    boolean continueWithPropertyPopulation = true;
    if (!mbd.isSynthetic() && this.hasInstantiationAwareBeanPostProcessors()) {
      Iterator var5 = this.getBeanPostProcessors().iterator();

      while(var5.hasNext()) {
        BeanPostProcessor bp = (BeanPostProcessor)var5.next();
        // 这里就是 Bean 实例化前的操作，执行 postProcessAfterInstantiation 方法
        if (bp instanceof InstantiationAwareBeanPostProcessor) {
          InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp;
          // 返回值为是否继续填充 Bean
          if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
            continueWithPropertyPopulation = false;
            break;
          }
        }
      }
    }
    //如果后处理器继续填充，则执行下面代码，原来这里是 if(!continueWithPropertyPopulation){return;}
    if (continueWithPropertyPopulation) {
      PropertyValues pvs = mbd.hasPropertyValues() ? mbd.getPropertyValues() : null;
      if (mbd.getResolvedAutowireMode() == 1 || mbd.getResolvedAutowireMode() == 2) {
        MutablePropertyValues newPvs = new MutablePropertyValues((PropertyValues)pvs);
        //这里以前是 == RootBeanDefinition.AUTOWIRE_BY_NAME，这种硬编码的方式，这就是魔法值了。要被 alibaba 编码规范插件检测出来的。
        if (mbd.getResolvedAutowireMode() == 1) {
          //根据名称自动注入
          this.autowireByName(beanName, mbd, bw, newPvs);
        }
        // 同上
        if (mbd.getResolvedAutowireMode() == 2) {
          //根据类型自动注入
          this.autowireByType(beanName, mbd, bw, newPvs);
        }

        pvs = newPvs;
      }

      boolean hasInstAwareBpps = this.hasInstantiationAwareBeanPostProcessors();
      boolean needsDepCheck = mbd.getDependencyCheck() != 0;
      PropertyDescriptor[] filteredPds = null;
      if (hasInstAwareBpps) {
        if (pvs == null) {
          pvs = mbd.getPropertyValues();
        }

        Iterator var9 = this.getBeanPostProcessors().iterator();

        while(var9.hasNext()) {
          BeanPostProcessor bp = (BeanPostProcessor)var9.next();
          if (bp instanceof InstantiationAwareBeanPostProcessor) {
            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp;
            // 在赋值前阶段，会执行下面的 postProcessProperties 方法
            PropertyValues pvsToUse = ibp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);
            //如果这里为空，则执行下面的方法
            if (pvsToUse == null) {
              if (filteredPds == null) {
                filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
              }

              pvsToUse = ibp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);
              if (pvsToUse == null) {
                return;
              }
            }

            pvs = pvsToUse;
          }
        }
      }

      if (needsDepCheck) {
        if (filteredPds == null) {
          filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
        }

        this.checkDependencies(beanName, mbd, filteredPds, (PropertyValues)pvs);
      }

      if (pvs != null) {
        this.applyPropertyValues(beanName, mbd, bw, (PropertyValues)pvs);
      }

    }
  }
}
```



### Spring Bean Aware 接口回调阶段

按顺序执行

+ BeanNameAware
+ BeanClassLoaderAware
+ BeanFactoryAware
+ EnvironmentAware //这个和接下来是 applicationContext 执行的
+ EmbeddedValueResolverAware
+ ResourceLoaderAware
+ ApplicationEventPublisherAware
+ MessageSourceAware
+ ApplicationContextAware

在执行 populateBean 方法之后，执行

```java
// 3
private void invokeAwareMethods(String beanName, Object bean) {
    if (bean instanceof Aware) {
        if (bean instanceof BeanNameAware) {
            ((BeanNameAware)bean).setBeanName(beanName);
        }

        if (bean instanceof BeanClassLoaderAware) {
            ClassLoader bcl = this.getBeanClassLoader();
            if (bcl != null) {
                ((BeanClassLoaderAware)bean).setBeanClassLoader(bcl);
            }
        }

        if (bean instanceof BeanFactoryAware) {
            ((BeanFactoryAware)bean).setBeanFactory(this);
        }
    }

}
// 2
protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {
        if (System.getSecurityManager() != null) {
            AccessController.doPrivileged(() -> {
                this.invokeAwareMethods(beanName, bean);
                return null;
            }, this.getAccessControlContext());
        } else {
            this.invokeAwareMethods(beanName, bean);
        }

        Object wrappedBean = bean;
        if (mbd == null || !mbd.isSynthetic()) {
            wrappedBean = this.applyBeanPostProcessorsBeforeInitialization(bean, beanName);
        }

        try {
            this.invokeInitMethods(beanName, wrappedBean, mbd);
        } catch (Throwable var6) {
            throw new BeanCreationException(mbd != null ? mbd.getResourceDescription() : null, beanName, "Invocation of init method failed", var6);
        }

        if (mbd == null || !mbd.isSynthetic()) {
            wrappedBean = this.applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
        }

        return wrappedBean;
    }
 protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
        BeanWrapper instanceWrapper = null;
        if (mbd.isSingleton()) {
            instanceWrapper = (BeanWrapper)this.factoryBeanInstanceCache.remove(beanName);
        }

        if (instanceWrapper == null) {
            instanceWrapper = this.createBeanInstance(beanName, mbd, args);
        }

        Object bean = instanceWrapper.getWrappedInstance();
        Class<?> beanType = instanceWrapper.getWrappedClass();
        if (beanType != NullBean.class) {
            mbd.resolvedTargetType = beanType;
        }

        synchronized(mbd.postProcessingLock) {
            if (!mbd.postProcessed) {
                try {
                    this.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
                } catch (Throwable var17) {
                    throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Post-processing of merged bean definition failed", var17);
                }

                mbd.postProcessed = true;
            }
        }

        boolean earlySingletonExposure = mbd.isSingleton() && this.allowCircularReferences && this.isSingletonCurrentlyInCreation(beanName);
        if (earlySingletonExposure) {
            if (this.logger.isTraceEnabled()) {
                this.logger.trace("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references");
            }

            this.addSingletonFactory(beanName, () -> {
                return this.getEarlyBeanReference(beanName, mbd, bean);
            });
        }

        Object exposedObject = bean;

        try {
          // 这里属性填入
            this.populateBean(beanName, mbd, instanceWrapper);
          //这里执行 各种 aware
            exposedObject = this.initializeBean(beanName, exposedObject, mbd);
        } catch (Throwable var18) {
            if (var18 instanceof BeanCreationException && beanName.equals(((BeanCreationException)var18).getBeanName())) {
                throw (BeanCreationException)var18;
            }

            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Initialization of bean failed", var18);
        }

        if (earlySingletonExposure) {
            Object earlySingletonReference = this.getSingleton(beanName, false);
            if (earlySingletonReference != null) {
                if (exposedObject == bean) {
                    exposedObject = earlySingletonReference;
                } else if (!this.allowRawInjectionDespiteWrapping && this.hasDependentBean(beanName)) {
                    String[] dependentBeans = this.getDependentBeans(beanName);
                    Set<String> actualDependentBeans = new LinkedHashSet(dependentBeans.length);
                    String[] var12 = dependentBeans;
                    int var13 = dependentBeans.length;

                    for(int var14 = 0; var14 < var13; ++var14) {
                        String dependentBean = var12[var14];
                        if (!this.removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                            actualDependentBeans.add(dependentBean);
                        }
                    }

                    if (!actualDependentBeans.isEmpty()) {
                        throw new BeanCurrentlyInCreationException(beanName, "Bean with name '" + beanName + "' has been injected into other beans [" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + "] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using 'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.");
                    }
                }
            }
        }

        try {
            this.registerDisposableBeanIfNecessary(beanName, bean, mbd);
            return exposedObject;
        } catch (BeanDefinitionValidationException var16) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Invalid destruction signature", var16);
        }
    }
// 后面几个 Aware
// 3
private void invokeAwareInterfaces(Object bean) {
        if (bean instanceof Aware) {
            if (bean instanceof EnvironmentAware) {
                ((EnvironmentAware)bean).setEnvironment(this.applicationContext.getEnvironment());
            }

            if (bean instanceof EmbeddedValueResolverAware) {
                ((EmbeddedValueResolverAware)bean).setEmbeddedValueResolver(this.embeddedValueResolver);
            }

            if (bean instanceof ResourceLoaderAware) {
                ((ResourceLoaderAware)bean).setResourceLoader(this.applicationContext);
            }

            if (bean instanceof ApplicationEventPublisherAware) {
                ((ApplicationEventPublisherAware)bean).setApplicationEventPublisher(this.applicationContext);
            }

            if (bean instanceof MessageSourceAware) {
                ((MessageSourceAware)bean).setMessageSource(this.applicationContext);
            }

            if (bean instanceof ApplicationContextAware) {
                ((ApplicationContextAware)bean).setApplicationContext(this.applicationContext);
            }
        }

    }
//ApplicationContextAwareProcessor implements BeanPostProcessor 
//2
    @Nullable
public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        AccessControlContext acc = null;
        if (System.getSecurityManager() != null && (bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware || bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware || bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)) {
            acc = this.applicationContext.getBeanFactory().getAccessControlContext();
        }

        if (acc != null) {
            AccessController.doPrivileged(() -> {
                this.invokeAwareInterfaces(bean);
                return null;
            }, acc);
        } else {
            this.invokeAwareInterfaces(bean);
        }

        return bean;
    }

//AbstractApplicationContext
// 1
 protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
        beanFactory.setBeanClassLoader(this.getClassLoader());
        beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
        beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, this.getEnvironment()));
   //这一步
        beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
        beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
        beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
        beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
        beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
        beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
        beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);
        beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
        beanFactory.registerResolvableDependency(ResourceLoader.class, this);
        beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
        beanFactory.registerResolvableDependency(ApplicationContext.class, this);
        beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));
        if (beanFactory.containsBean("loadTimeWeaver")) {
            beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
            beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
        }

        if (!beanFactory.containsLocalBean("environment")) {
            beanFactory.registerSingleton("environment", this.getEnvironment());
        }

        if (!beanFactory.containsLocalBean("systemProperties")) {
            beanFactory.registerSingleton("systemProperties", this.getEnvironment().getSystemProperties());
        }

        if (!beanFactory.containsLocalBean("systemEnvironment")) {
            beanFactory.registerSingleton("systemEnvironment", this.getEnvironment().getSystemEnvironment());
        }

    }

```



### Spring Bean 初始化前阶段


BeanPostProcessor#postProcessBeforeInitialization

### Spring Bean 初始化阶段

依次往下执行

注解 @Postconstructor

接口 InitializingBean 

元信息配置 @Bean（init-method="init")

### Spring Bean 初始化后阶段

BeanPostProcessor#postProcessAfterInitialization

### Spring Bean 初始化完成阶段

SmartInitializingSingleton#afterSingletonsInstantiated

适合 ApplicationContext 中回调

### Spring Bean 销毁前阶段


DestructionAwareBeanPostProcessor#postProcessBeforeDestruction

### Spring Bean 销毁阶段

执行次序依次往下执行

+ @PreDestroy 标注方法
+ 实现 DisposableBean 接口的 destroy() 方法
+ 自定义销毁方法 (destroy-mehod)



### Spring Bean 垃圾收集

+ Bean 垃圾回收（GC）
  + 关闭 Spring 容器（应用上下文）
  + 执行 GC
  + Spring Bean 覆盖的 finalize() 方法被回调



## AOP原理

java 的 Proxy，cglib（asm）动态代理，实现 aop，做方法前后等增强。

利用代理类，来增强原有类。

https://juejin.im/post/5bf4fc84f265da611b57f906

## JDK动态代理和cglib的实现的区别

一个是接口，一个做它的子类，对原有类型进行提升

### JDK动态代理实现



### Cglib 实现动态代理

本质上是实现一个子类，去提升该类的方法。所以不要将类或方法设置成 final 类型的，类设置了会报错，作为不了他的子类，方法设置成 final，只能 invoke 不能增强该方法 。

```java
import org.springframework.cglib.proxy.Enhancer;
import org.springframework.cglib.proxy.MethodInterceptor;

public class CGLIBDemo {

    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(CGLIBDemo.class);
        enhancer.setCallback((MethodInterceptor) (o, method, objects, methodProxy) -> {
            System.err.println("Before invoke " + method);
            Object result = methodProxy.invokeSuper(o, objects);
            System.err.println("After invoke" + method);
            return result;
        });

        CGLIBDemo cglibDemo = (CGLIBDemo) enhancer.create();
        cglibDemo.test();
        System.out.println(cglibDemo);
    }

    public void test(){
        System.out.println("I'm test method");
    }
}

```



## javassist 动态生成字节码

## Spring 是如何解决循环依赖的

// TODO

首先 prototype 不让循环依赖

其次是构造器注入依赖，必须提供无参构造器，让 bean 能够实例化，如果没有，那也会报错。

最终，spring 会先实例化对象，将对象放入 earlySingletonObjects 中，如果循环依赖开始，优先查找 earlySingletonObjects。

```java
public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry {
  // 三级缓存
    private final Map<String, Object> singletonObjects = new ConcurrentHashMap(256);
    private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap(16);
    private final Map<String, Object> earlySingletonObjects = new HashMap(16);
  // 上面三个 map 解决循环依赖。如果是非单例模式，构造器注入，循环依赖无解，直接抛出异常。在 AbstractBeanFactory 中
    private final Set<String> registeredSingletons = new LinkedHashSet(256);
    private final Set<String> singletonsCurrentlyInCreation = Collections.newSetFromMap(new ConcurrentHashMap(16));
    private final Set<String> inCreationCheckExclusions = Collections.newSetFromMap(new ConcurrentHashMap(16));
    @Nullable
    private Set<Exception> suppressedExceptions;
    private boolean singletonsCurrentlyInDestruction = false;
    private final Map<String, Object> disposableBeans = new LinkedHashMap();
    private final Map<String, Set<String>> containedBeanMap = new ConcurrentHashMap(16);
    private final Map<String, Set<String>> dependentBeanMap = new ConcurrentHashMap(64);
    private final Map<String, Set<String>> dependenciesForBeanMap = new ConcurrentHashMap(64);
    public DefaultSingletonBeanRegistry() {
    }
}
```



所有面试题

https://blog.csdn.net/ThinkWon/article/details/104391081

# Spring MVC

## spring mvc 具体请求执行过程

handlerMapping -> handler -> 

# Spring Cloud 

## Eureka/Nacos

租约机制。

Eureka 实现了 AP。任何 Server 都是主 Server，Server 与 Server 之间同步需要时间，可能会出现不一致的情况。Consistency

Nacos 实现了两种 AP，CP 模式，需要哪种可以指定。

## Feign/Dubbo

## hystrix/Sentinel（哨兵）

Sentinel 除了熔断限流，还有分布式应用监控的功能

## Gateway/Zuul

## RocketMQ

我选择 Confluent Kafka

## 分布式服务配置中心Apollo

挺好用，就是要配置 mysql，启动三个不同的 jar，内部实现是 Eureka + http long polling 长连接。

# Mybatis

## Mybatis缓存机制

### 一级缓存

基于 PerpetualCache 的 HashMap 本地缓存， 其存储作用域为 Session， 当 Session flush 或 close 之后， 该 Session 中的所有 Cache 就 将清空， 默认打开一级缓存。

### 二级缓存

与一级缓存其机制相同， 默认也是采用 PerpetualCache， HashMap 存储， 不同在于其存储作用域为 Mapper(Namespace)， 并且可自定义存储源， 如 Ehcache。 默认不打开二级缓存， 要开启二级缓存， 使用二级缓存属性类需要实 现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache/> ， 对于缓存数据更新机制， 当某一个作用域(一级缓存 Session/二级缓存 Namespaces)的进行了 C/U/D 操作后， 默认该作用域下所有 select 中的缓存将被 clear 。

# 设计模式

## 简单工厂模式

### 定义

简单工厂模式又叫静态方法模式。

补充：根据输入参数，或调用不同静态方法创建不同类型实例。

### 实例代码

```java

```



## 单例模式

### 定义

### 应用场景

注意事项

1. 对于初始化耗时的类来说，饿汉式单例更适合。
2. Spring 采用 Hash 散列表来实现单例，自己 new [SpringBean] 还是会创建不同对象。

### 示例代码

```java
public class Singleton{
    // 只有低版本的 Java 才会有指令重排问题，所以这里没加 volatile
    // 我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题，解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序
    private static Singleton instance;
    
    private Singleton(){
        //  防止反射创建两次实例
        if(instance != null){
        	throw new IllegalAccessException();
    	}           
    }
    public static Singleton getInstance(){
        if(instance == null){
            synchronized(Singleton.class){
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

## 构建器模式

### 定义

将一个复杂对象的构建与其表示相分离，使得同样的构建过程（稳定）可以创建不同的表示（变化）。

### 应用场景

https://time.geekbang.org/column/article/199674

+ 我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。

+ 如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。

+ 如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来设置属性值的方式就不适用了

### 示例代码

另外，Mybatis 也有 SqlSessionFactoryBuilder 来构建 SqlSessionFactory（虽然也可以用 Java Bean 的方式）。

```java
public final class BeanDefinitionBuilder {
  	private final AbstractBeanDefinition beanDefinition;
  	private int constructorArgIndex;
    // 提供静态工厂方法，返回一般 BeanDefinitionBuilder
    public static BeanDefinitionBuilder genericBeanDefinition(String beanClassName) {
        BeanDefinitionBuilder builder = new BeanDefinitionBuilder(new GenericBeanDefinition());
        builder.beanDefinition.setBeanClassName(beanClassName);
        return builder;
    }
    // 省略其他相同类型方法.....

    // init-method
    public BeanDefinitionBuilder setInitMethodName(@Nullable String methodName) {
        this.beanDefinition.setInitMethodName(methodName);
        return this;
    }
    // detroy-method
    public BeanDefinitionBuilder setDestroyMethodName(@Nullable String methodName) {
        this.beanDefinition.setDestroyMethodName(methodName);
        return this;
    }
    // scope  defualt singleton
    public BeanDefinitionBuilder setScope(@Nullable String scope) {
        this.beanDefinition.setScope(scope);
        return this;
    }
    // 省略其他类型方法....

    public AbstractBeanDefinition getBeanDefinition() {
        this.beanDefinition.validate();
        return this.beanDefinition;
    }
}

//使用
public class BeanDefinitionAPI{
    public GenericBeanDefinition getGeneriBeanDefinition(){
        return (GenericBeanDefinition)BeanDefinitionBuilder
            .genericBeanDefinition("org.springframework.web.client.RestTemplate")
            .setScope("singleton")
            .getBeanDefinition();
    }
}
```

## 原型模式

## 代理模式

## 桥接模式

## 适配器模式

## 门面模式

## 组合模式

## 享元模式

## 迭代器模式



## JDK源码用到了哪些设计模式

https://blog.csdn.net/baiye_xing/article/details/76427717

# Mysql/Oracle

## 一条 SQL 的执行过程

// TODO 待完善

词法解析 -> 如果开启了缓存（5.7后默认关闭），如果没有修改内容，则返回结果 -> 词法解析生成树 -> 调用 innodb -> 

## 事务隔离级别

读未提交 Read Uncommitted

读已提交 Read Committed

可重复读 Repeatable Read

串行化 Serializable

分别解决了事务执行的不同情况。

这些是事务型数据库设计的基本概念

## 通过 Explain 分析并优化 SQL

两年前使用 PL/SQL 对慢 SQL 的解释查询计划小优化。其实还有其他的 SQL 优化，没展示出来，项目后期帮其他组员重构优化代码和 SQL。

https://yq.aliyun.com/articles/687976?spm=a2c4e.11155435.0.0.5f4633120ERia8

## BaiKalDB

百度开源的，基于 Mysql 以及 RockDB 实现的分布式数据库。通过 Partition Region 的概念实现，理论上没有存储瓶颈。

# Redis

## Reids 6 个底层数据结构

+ 简单动态字符串 SDS
+ List 双向链表
+ ZipList 压缩列表
+ SkipList 跳表
+ HashMap 哈希表
+ 整数数组

List、Hash、Sorted Set 优先使用 ZipList，当数据到达一定阈值时，变成对应实现

Set 优先使用整数数组， 当数据到达一定阈值时 HashMap

SDS Simple Dynamic String 其实存储耗费挺多内存的。// TODO《Redis 设计与实现》内容补充

## Redis SkipList

有序链表前提下

加上多层级索引实现高效查找

插入和查询复杂度都是 log(n)

## Redis单线程

所谓的单线程，其实是指 Redis 对读和写键值的时候是单线程操作（这里就会导致某个命令如果执行耗时过长，会导致 Redis 实例卡住），和传统的 Socket 单线程 accept 接收不同。Redis 采用了 select/epoll IO多路复用的方式，将所有到达的 TCP 请求，进行了汇总到事件队列中，然后由 Redis 主线程一条条执行命令。

所谓单线程，是指网络 IO 和键值对读写是由一个线程来完成的。用于集群数据同步、持久化（save/bgsave）、异步删除都是由其他线程来完成的。

## Redis6 

默认为关闭，需手动设置开启

## Redis 哨兵集群

一主多从，客观下线

// TODO 判断过程

## Redis 分片

16384个哈希槽，CRC16

// TODO 分配哈希槽命令

## Redis 集群同步

一主多从，RDB 同步

// TODO 同步步骤

### Redis 源码优化

利用 taskset 将主线程进行绑核操作。

# Netty

## Netty Zero Copy

https://zhuanlan.zhihu.com/p/78869158

## Netty 解决粘包

# 数据结构
## 二叉树遍历

前序：根左右

中序：左根右

后序：左右根

## 二叉树

```java
public class Node{

	Node left, right;

	int val;

  public Node(int val){
    this.val = val;	
  }
}
```

### 前序遍历

```java
 public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList();
        LinkedList<TreeNode> stack = new LinkedList();
        if(root == null){
            return res;
        }
        stack.add(root);
        while(!stack.isEmpty()){
            TreeNode node = stack.pollLast();
            res.add(node.val);
            if(node.right != null){
                stack.add(node.right);
            }
            if(node.left != null){
                stack.add(node.left);
            }
        }
        return res;
 }
```

### 求二叉树最大深度

```java
public int maxDepth(TreeNode root) {
  if (root == null) {
    return 0;
  } 

  int leftHeight = maxDepth(root.left);
  int rightHeight = maxDepth(root.right);

  return Math.max(leftHeight, rightHeight) + 1;
}
```

# 算法

## 冒泡排序

``` java
public void sort(int[] arr) {
        int size = arr.length;
        int i, j;
        //pos变量用来标记循环里最后一次交换的位置
        int k = size - 1, pos = 0;

        //一共要排序size-1次
        for (i = 0; i < size - 1; i++) {
            //每次遍历标志位都要先置为0，才能判断后面的元素是否发生了交换
            int flag = 0;
            //选出该趟排序的最大值往后移动
            for (j = 0; j < k; j++) {
                if (arr[j] > arr[j + 1]) {
                    int tmp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = tmp;
                    //只要有发生了交换，flag就置为1
                    flag = 1;
                    //循环里最后一次交换的位置 j赋给pos
                    pos = j;
                }
            }
            k = pos;
            //判断标志位是否为0，如果为0，说明后面的元素已经有序，就直接return
            if (flag == 0) {
                return;
            }
        }
}
```

[演示动态图](https://visualgo.net/zh/sorting)

## 快速排序

## 二分搜索

## 插入排序 insert

## 归并排序 merge

## 选择排序 select

# LeetCode 刷题

# 大型分布式网站架构

## 架构

单体 -> SOA -> 微服务 -> serveless

## 负载均衡策略

1. 轮询（Round Robin）
2. 随机
3. hash 取模
4. 加权轮询（和轮询一样，只不过根据权重，重复的IP地址根据权重变成多份）
5. 加权随机
6. 最小连接数
7. 动态选择连接数最小服务器

## 常见权限设计

+ ACL：Access-Control List，访问控制列表。
+ RBAC：Role-Based Access Control，基于角色的权限控制。
+ ABAC：Attribute-Based Access Control，基于属性的权限控制。
+ PBAC：Policy-Based Access Control，基于策略的权限控制。

ACL示例：MySQL，MongoDB，HBase 都是以 ACL 作为权限控制思想，MySQL 在赋予用户权限时，有个 acl_users 数组进行存储 all_user 信息（不仅在 mysql.user 这个表里加数据）。

RBAC示例：常见的权限系统，在 人员 1<-->n 角色 1<-->n 权限。

## Oauth2

https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html

其实现 Spring Security Oauth2

## 如何设计海量数据的存储系统

参考 TiDB，或者 GFS 升级版 Colossus（套娃）。

## Consistent Hash 一致性哈希

基础：将 Hash 函数的值域空间组织成一个圆环，计算出对应的 key 的 hash 值在环上对应的区间。

进阶：对每个节点进行计算多个 Hash 值，引入虚拟节点，虚拟节点映射到真实节点。 

https://www.infoq.cn/article/7cBOXVbB6B5V0BJh6Rfx

## 缓存的实现原理，设计缓存要注意什么

https://juejin.im/post/5b849878e51d4538c77a974a

进程内缓存Guava cache 、Ecache，也可以使用其提供的同步机制同步多个进程间缓存。

// TODO《深入分布式缓存》

## 操作系统的页式存储

https://www.tomorrow.wiki/archives/334

page cache。最好不要改，redis 利用 page cache 做了优化，改大了影响性能。

// TODO 详细解释 page cache

## 分布式Session

+ 可以将用户的 token 作为键值，使用 登陆 -> UUID -> token -> token为键，用户信息为值 ，将用户信息放入 memcache/redis集群之中。

+ 对用户 token/id 采用 Hash 取模的方式，将用户 session 强行绑定在固定机器上，就不用跨实例共享 session 了。

## Http请求的过程与原理

1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束

## TCP 连接的特点

## TCP如何保证安全可靠的

ACK机制，三次握手，四次挥手 

## 服务稳定性

### 依赖管理

理清调用链路、流量控制、慢调用降级。

### 优雅降级

为避免单个服务实例宕机导致服务雪崩，通常有集群管理或服务熔断机制，可以两个一起用。dubbo 服务设置里面手动设置阈值。

### 服务分级

对服务实例设置白名单机制，对不同服务进行分级处理，优先处理等级高的服务请求。我觉得可以把调用失败的请求，转到 mq 上，由一群专门用于处理调用失败请求的服务，进行定时执行从 mq 尝试拉取失败请求，进行重试。

### 开关

如果服务消费者 A、B、C 都依赖服务提供者 D，如果前面做了服务分级，则可以在实例负载超过警戒水位线，进行关闭对低优先级的请求。

### 应急预案

提前做好扩容方案。

Sentinel 都符合了这些要求（应急预案不含）。本质上都是舍车保帅，保证能用的服务不挂，保证优先级高的服务能用，提前准备应对方案。

## 高并发系统设计

### 操作原子性

volatile，synchronized

### 多线程同步

juc

### 数据一致性

**强一致性**

要求无论数据的更新操作是在哪个副本上执行，之后所有的读操作都要能够获取到更新的最新数据。

**弱一致性**

系统的某个数据被更新后，后续对该数据的读取操作到的可能是更新前的值，也可能是更新后的值。全部用户完全读取到更新后的数据需要经过一段时间，这段时间称为“不一致性窗口”

**最终一致性**

最终一致性是弱一致性的特殊形式，这种情况下系统保证用户最终能够读取到某个操作对系统的更新，“不一致窗口”的时间依赖于网络的延迟、系统的负载和副本的个数。

### 系统的可扩展性

通过简单加机器，简单的配置就能实现更高吞吐量，那这就是易扩展。

### 并发减库存

https://time.geekbang.org/column/article/40743

减库存一般有三种

+ 下单减库存
+ 付款减库存
+ 预扣减库存

**下单减库存**可以通过数据库事务控制，但是下了单不一定付款。

**付款减库存**，如果并发比较高，可能出现买家下单后付不了款的情况，因为商品已经被其他人买走了。

**预扣库存**，买家下单后，库存为其保留一定时间（如10分钟），超过这个时间，库存将会自动释放，释放后其他买家可以继续购买（有点锁的味道）。在买家付款前，系统会校验订单的库存是否还有保留，如果没有保留，则再次尝试预扣；如果库存不足（预扣失败），则不允许继续付款，如果预扣成功，则完成付款并实际地去减库存。

对商品剩余数量的查询，可以使用缓存 Ecache/Guava Cache 进行本地缓存返回。

**应用层做排队。**按照商品维度设置队列顺序执行，这样能减少同一台机器对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用数据库连接的数量，防止热点商品占用太多的数据库连接。

**数据库层做排队**。阿里的数据库团队开发了针对这种 MySQL 的 InnoDB 层上的补丁程序（patch），可以在数据库层上对单行记录做到并发排队。

## 性能优化措施

### 前端性能优化

1. 页面的 HTTP 请求数量（尽量减少请求数量，像QQ音乐网页版就是反例，大量无用的 debug 请求）
2. 是否使用 CDN 网络（静态资源上 CDN）
3. 是否使用压缩

### Java 程序优化

1. 合理使用单例模式。提升对象复用性，减少内存开销
2. Future 模式（FutureTask，异步执行任务）// TODO 使用异步线程池写代码
3. 线程池（避免对象频繁创建、销毁，使用池化思想，在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用）
4. 选择就绪（使用 NIO）// TODO 使用 NIO 代码
5. 减少上下文切换 （2 \* cpu核心数 \* cpu核数 + 1）// TODO 补充文章说明为什么是这个数
6. 降低锁竞争（1. 合理减少 synchronized 域的范围，2. 减小锁的粒度 3.使用读写锁比使用独占锁提供更高的并发量 ）

### 压缩

Kafka 默认不使用压缩，合理使用压缩，可以减少带宽使用。

GZIP、Snappy 、LZ4、Zstandard 算法（简写为 zstd）

在 Producer 端和 Broker 端设置相同（或者 Broker 端不改 compression.type 参数，默认为 producer 端的压缩方法）。 

在吞吐量方面：LZ4 > Snappy > zstd 和 GZIP；

而在压缩比方面，zstd > LZ4 > GZIP > Snappy。

### 结果缓存

从数据库开始使用缓存（不建议） -> 进程内缓存 Guava cache，Ecache -> 跨进程缓存 （Redis ，对值结构；要求复杂点的系统不推荐Memcached）-> 静态资源缓存（CDN）

### 数据库查询性能优化

1. 合理使用索引（explain，解释计划查询，对特定业务进行建立索引进行查询优化）[例子](https://yq.aliyun.com/articles/687976?spm=a2c4e.11155435.0.0.5f4633120ERia8) oracle 是 explain plan for
2. 反范式设计（适当冗余字段，尽量避免多表操作）
3. 使用查询缓存（不推荐，5.7 之后默认关闭，8.0 不准开，使用起来很多坑）
4. 使用搜索引擎（ElasticSearch 加速 Like 查询以及很多复杂的查询）
5. 使用 Key-Value 数据库（Hbase， TDH 的 HyperBase，通过设计合理的 RowKey 加速查询）// TODO 写一篇合理 RowKey 设计文章

### GC 优化

分析 dump 日志，合理设置启动参数，Xms 设置为机器内存的 65% - 70%

### 硬件性能提升

其实硬件性能提升是所有优化里面，能最简单，最大的优化。生产上都是 Nginx + F5 来提升单体应用。

### Java应用故障排查

// TODO 把 19 年如何解决 CPU 使用率飙升的命令写出来

## 数据分析

使用 Hadoop 进行数据分析。

Storm 是 2011 年 Twitter 开源的一个实时的分布式流式处理系统，有点类似于 Hadoop 提供的大数据解决方案，但是它要处理的对象是没有终点的数据流（也叫无界数据流），而非 Hadoop 的 MapReduce 那样的批处理系统。

## 日志收集系统 Chukwa

## 离线数据分析

## 数据同步

过程往往是从 OLTP 库中，以及日志系统中，提取和清洗（数据清洗可以用 Kafka Stream）所需要的数据到 OLAP 系统（所在的银行当前系统就是这样的）。构建在 hive 平台，然后在 OLAP 系统上进行多维度复杂的数据分析和汇总操作，利用这些数据构建数据报表，进行前端展示。我们做的是每天全量同步。使用的 Sqoop，没用 DataX 。

### 离线同步（全量同步）

使用 sqoop，全量表

### 实时同步（增量同步）

使用 mysql 主从机制，通过伪装成从库进行 binlog  ---> Kafka （任意 MQ） ---> 其他库。增量表

#  Zookeeper

## Zookeeper 介绍

`Zookeeper` 是一个开源的分布式协调服务软件，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步操作。最终，将简单易用的接口和性能高效，功能稳定的系统提供给用户。

分布式应用程序可以基于 `Zookeeper` 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。

Zookeeper 保证了分布式一致性特性：

1. 顺序一致性
2. 原子性
3. 单一视图
4. 可靠性
5. 实时性（最终一致性）

## Zookeeper 提供了什么？

1. 文件系统
2. 通知机制

## Zookeeper 文件系统

`Zookeeper` 提供了一个多层级的节点命名空间（节点称为 `znode`）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。`Zookeeper` 为了保证高吞吐和低延迟，在内存中维护了这个树状目录结构，这种特性使得 `Zookeeper`不能用于存放大的数据，每个节点的存放数据上限为 1M。

## ZAB 协议

`ZAB` 协议是为分布式协调服务 `Zookeeper `专门设计的一种支持崩溃恢复的原子广播协议。

`ZAB`协议包括两种基本的模式：崩溃恢复和消息广播。

当整个`Zookeeper`集群刚刚启动或者 `Leader`服务器宕机、重启或者网络故障导致不存在过半的服务器与`Leader`服务器保持正常通信时，所有进程（服务器）进入崩溃恢复模式，首先选举产生新的`Leader`服务器，然后集群中`Follower`服务器开始与新的`Leader`服务器进行数据同步，当集群中超过半数及其与该 `Leader`服务器完成数据同步之后，退出恢复模式进入消息广播模式，`Leader`服务器开始接收客户端的事务请求生成事务提案进行事务请求处理。

## 四种类型的数据节点 Znode

`PERSISTENT`：持久节点，除非手动删除，否则节点一直存在于`Zookeeper`上

`EPHEMERAL`：临时节点 临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与`Zookeeper`连接断开不宜一定会话失效），那么这个客户端创建的所有临时节点都会被移除。[`Kafka`集群就是基于临时节点](#broker-zk)。

`PERSISTENT_SEQUENTIAL`：持久顺序节点 基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字

`EPHEMERAL_SEQUENTIAL`：临时顺序节点 基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由副节点维护的自增整型数字。

## ZooKeeper Wather 机制 -- 数据变更通知

Zookeeper允许客户端向服务端的某个Znode注册一个Watcher监听，当服务端的一些指定事件触发了这个Watcher，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据Watcher通知状态和事件类型做出业务上的改变。

**工作机制**：

1. 客户端注册watcher 

2. 服务端处理watcher 

3. 客户端回调watcher

**Watcher特性总结**：

**一次性**

无论是服务端还是客户端，一旦一个Watcher被触发，Zookeeper都会将其从相应的存储中移除。这样的设计有效的减轻了服务端的压力，不然对于更新非常频繁的节点，服务端会不断的向客户端发送事件通知，无论对于网络还是服务端的压力都非常大。

**客户端串行执行**

客户端Watcher回调的过程是一个串行同步的过程。

**轻量**

1. Watcher通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具体内容。

2. 客户端向服务端注册Watcher的时候，并不会把客户端真实的Watcher对象实体传递到服务端，仅仅是在客户端请求中使用boolean类型属性进行了标记。

watcher event异步发送watcher的通知事件从server发送到client是异步的，这就存在一个问题，不同的客户端和服务器之间通过socket进行通信，由于网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于Zookeeper本身提供了ordering guarantee，即客户端监听事件后，才会感知它所监视znode发生了变化。所以我们使用Zookeeper不能期望能够监控到节点每次的变化。Zookeeper只能保证最终的一致性，而无法保证强一致性。

注册watcher getData、exists、getChildren

触发watcher create、delete、setData

当一个客户端连接到一个新的服务器上时，watch将会被以任意会话事件触发。当与一个服务器失去连接的时候，是无法接收到watch的。而当client重新连接时，如果需要的话，所有先前注册过的watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，watch可能会丢失：对于一个未创建的znode的exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个watch事件可能会被丢失。

# Kafka

## Kafka 各个名词概述

Topic

Broker

Partition

Producer

Consumer

Leader Replica

Follower Replica

Rebalance（辣鸡）

Consumer Offset

Consumer Group

## <span id="broker-zk">Broker注册</span>

**Broker是分布式部署并且相互之间相互独立，但是需要有一个注册系统能够将整个集群中的 Broker 管理起来**，此时就使用到了Zookeeper。在 Zookeeper 上会有一个专门**用来进行Broker服务器列表记录**的节点：

/brokers/ids

每个Broker在启动时，都会到Zookeeper上进行注册，即到/brokers/ids下创建属于自己的节点，如/brokers/ids/[0...N]。

Kafka使用了全局唯一的数字来指代每个Broker服务器，不同的Broker必须使用不同的Broker ID进行注册，创建完节点后，**每个Broker就会将自己的IP地址和端口信息记录**到该节点中去。其中，Broker创建的节点类型是临时节点，一旦Broker宕机，则对应的临时节点也会被自动删除。

## Kafka Zero Copy



## Kafka Partition

分区，一个 Topic 可以有多个 Partion，一个 Partition 仅且仅被一个消费者组的一个消费者消费。

## Kafka 副本机制

只有 Leader 副本才供外界读写，Follower 副本只是作为冗余，怕 Leader 副本 down 掉数据全部丢失。// TODO Leader Follower 同步机制。

## Kafka 跨机房同步数据

## Kafka 高水位

# Lucene

## Lucene全文搜索的原理

https://blog.csdn.net/yangqian201175/article/details/51462413

《Lucene in action》

# ELK

## ElasticSearch 聚合操作

## ElasticSearch 查询

支持多种类型查询，返回对应 score

## Logstash

docker pull docker.elastic.co/logstash/logstash:7.1.0

## Kibana 

中文环境设置 I18N_LOCALE=zh-CN

# BigData

## HDFS

hadoop 分布式文件系统。NameNode + DataNode，NameNode 只存 metadata，实际文件存在各个 DataNode。

## MapReduce

MapReduce 是一种处理海量数据的并行编程模型和计算框架，用于对大规模数据集进行并行计算。

MapReduce 一个任务的运行需要由 JobTracker 和 TaskTracker 两类空志节点的配合来完成，JobTracker 将 Mappers 和 Reducers 分配给空闲的 TaskTracker 后，有TaskTracker 来执行这些任务。MapReduce 框架尽量在那些存储数据的节点（如 DataNode）上来执行计算任务，采用移动计算而非移动数据的思想，减少数据在网络中传输，以此来提高计算效率。同时 JobTracker 也负责任务的容错管理，如果某个 TaskTracker 发生故障，JobTracker 会重新进行任务调度。

## Hive

将 SQL 解释成 mapReduce 任务。

Hive是早期将高级查询语言SQL引入**Hadoop**平台的引擎之一，早期的Hive服务器进程被称作Hiveserver1；Hiveserver1既不支持处理并行的多个连接，又不支持访问授权控制；后来这两个问题在Hiveserver2上被解决，Hiveserver2能够使用grant/revoke语句来限制用户对数据库、表、视图的访问权限，行列权限的控制是通过生成视图来实现的；但Hiveserver2的授权管理体系被认为存在问题，那就是任何通过认证登陆的用户都能够为自己增加对任何资源的访问权限。也就是说Hiveserver2提供的不是一种安全的授权体系，Hiveserver2的授权体系是为防止正常用户误操作而提供保障机制；不是为保护敏感数据的安全性而设计的。然而这些更多的是某些公司的说辞，事实上Hiveserver2自身的安全体系也在逐步完善，上述问题也在快速修复中。

### 连接

从 hive 连接中可以看出用的是 Hiveserver2

 beeline -u jdbc:hive2://olap1:10000/ --maxWidth=1000

### 数据仓库

从 web 开发到离线数仓，一个用 SQL 开发，到另一个用 SQL 开发。换个地方 crud 而已

UDF，UDAF，UDTF。脱敏函数（UDF），聚合函数（UDAF 自定义count，sum），UDTF 

// TODO 把写的求两列线性回归方程相关系数 UDAF 函数代码贴出来。

UDF 一进一出，实现 UDF 接口，编写**evaluate**方法，可用作脱敏函数，对数据进行脱敏。

```java
class SimpleUDFExample extends UDF{
    public Text evaluate(Text input){
        return new Text("Hello " + input.toString());
    }
}
```

UDAF 多进一出，实现 AbstractGenericUDAFResolver，可用作实现自定义聚合函数。下面是求两个列的线性方程的相关系数。

```java
import static org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory.javaDoubleObjectInspector; 
    
@Description(name = "regression",value="_FUNC_(double x,avg(x),double y,avg(y)) - computes the simple linear regression") 
public class LinearRegressionUDAF extends AbstractGenericUDAFResolver{
    public GenericUDAFEvaluator getEvaluator(GenericUDAFParameterInfo info)throws SemanticException{
        ObjectInspector[] inputIOS = info.getPrarameterObjectInspectors();
    }
}
```

## HBase

HBase是一个高可靠、高性能、面向列、可伸缩的分布式数据库，是谷歌 BigTable 的开源实现，主要用来存储非结构化和半结构化的松散数据，运行在 HDFS 之上。

设计 RowKey 尽量将数据均地分布在各个 Region 上，并且 RowKey 为等长，用于拼接 RowKey 的列必须是确定长度的值，高频词往前提，同样查询频率的，辨识度高，更短的列往前提。

没有特殊要求，一个列族就可以满足大部分要求。

## HyperBase

星环增强了 HBase，赋予了它更多的字段类型，变成了 HyperBase。查询更方便，千亿数据，查询秒返回。支持普通单表查询，多表查询慢，聚合操作更慢。聚合操作使用以下部件实现。利用 ElasticSearch 作为二级索引（这边叫全文索引），加速各个条件的查询，但是聚合查询非常非常非常慢。

## Kylin

## Spark

Spark SQL 也可以将 SQL 转换成 MR 任务，星环的 inceptor 就整合了 Spark。Hive-on-spark，将 Hive 的 MR 任务转换成 Spark 的 job。

## Flink

## CDH TDH

Confluent Data Hub，Transwarp Data Hub 一站式大数据平台

## OLAP

Online analytical processing **联机分析处理**

OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。

OLAP由三个基本的分析操作组成：上卷（roll-up）、钻取（drill-down）、切片（slicing）和切块（dicing）。上卷涉及可以在一个或多个维度中累积和计算的数据的聚合。例如，所有的销售办事处汇总到销售部门，以预测销售趋势。相比之下，钻取是一种允许用户浏览详细信息的技术。例如，用户可以查看组成一个地区销售额的单个产品的销售额。切片和切块是说，用户可以从OLAP多维数据集中取出（切片）一组特定的数据，并从不同的角度查看（切块）切片

https://zh.wikipedia.org/wiki/%E7%B7%9A%E4%B8%8A%E5%88%86%E6%9E%90%E8%99%95%E7%90%86

## OLTP

**联机事务处理**（**OLTP**, Online transaction processing）是指透过[信息系统](https://zh.wikipedia.org/wiki/資訊系統)、电脑[网络](https://zh.wikipedia.org/wiki/網路)及[数据库](https://zh.wikipedia.org/wiki/資料庫)，以在线交易的方式处理一般即时性的作业资料，和更早期传统数据库系统大量批量的作业方式并不相同。OLTP通常被运用于自动化的资料处理工作，如订单输入、[金融](https://zh.wikipedia.org/wiki/金融)业务…等反复性的日常性交易活动。 和其相对的是属于决策分析层次的[联机分析处理](https://zh.wikipedia.org/wiki/線上分析處理)（OLAP）。

[来自](https://zh.wikipedia.org/wiki/%E7%B7%9A%E4%B8%8A%E4%BA%A4%E6%98%93%E8%99%95%E7%90%86)

# J2EE 规范

## JMS

[下面的来自oracle 官方文档](https://docs.oracle.com/javaee/6/tutorial/doc/bncdr.html)

《大型分布式网站架构·设计与实践》中只是一笔带过一些概念，没有 JMS 实际代码，然后用 ActiveMQ & JMS 的标题。

### 定义

Java Message Service 是一组 Java 应用程序接口，它提供消息的创建、发送、接收、读取等一系列的服务。

{% hideToggle 原文 %}

The Java Message Service is a Java API that allows applications to create&sbquo; send&sbquo; receive&sbquo; and read messages

{% endhideToggle %}

JMS 定义了一组公共应用程序接口和相应的语法，是一种通用的 API。

{% hideToggle 原文 %}

the JMS API defines a common set of interfaces and associated semantics that allow programs written in the Java programming language to communicate with other messaging implementations

{% endhideToggle %}

它定义了五种消息类型，如下。

{% hideToggle 原文 %}

The JMS API defines five message body formats&sbquo; also called message types&sbquo; which allow you to send and receive data in many different forms and which provide compatibility with existing messaging formats.

{% endhideToggle %}

<style>
table th:first-of-type {
    width: 20%;
}
table th:nth-of-type(2) {
    width: 80%;
}
</style>



| Message Type    | Body Contains                                                |
| --------------- | ------------------------------------------------------------ |
| `TextMessage`   | A `java.lang.String` object (for example, the contents of an XML file). |
| `MapMessage`    | A set of name-value pairs, with names as `String` objects and values as primitive types in the Java programming language. The entries can be accessed sequentially by enumerator or randomly by name. The order of the entries is undefined. |
| `BytesMessage`  | A stream of uninterpreted bytes. This message type is for literally encoding a body to match an existing message format. |
| `StreamMessage` | A stream of primitive values in the Java programming language, filled and read sequentially. |
| `ObjectMessage` | A `Serializable` object in the Java programming language.    |
| `Message`       | Nothing. Composed of header fields and properties only. This message type is useful when a message body is not required. |

## JDBC

### 1.0 规范

+ Connection

+ Statement

+ ResultSet

+ DriverManager.getDriver(url);

### 2.0 规范

数据源

+ DataSource		这个接口是在JDBC 2.0规范可选包中引入的API。它比DriverManager更受欢迎，因为它提供了更多底层数据源相关的细节，而且对应用来说，不需要关注JDBC驱动的实现。JDBC API中只提供了DataSource接口，没有提供DataSource的具体实现，DataSource具体的实现由JDBC驱动程序提供。主流的数据库连接池也提供了其实现，如 Druid，c3p0，Hikaricp
+ CommonDataSource 

连接池相关

+ ConectionPoolDataSource 支持缓存和复用Connection对象，这样能够在很大程度上提升应用性能和伸缩性。
+ PooledConnection
+ ConnectionEvent
+ ConnectionEventListener

ResultSet 扩展

+ RowSet 继承自java.sql包下的ResultSet接口，相较于java.sql.ResultSet而言，RowSet的离线操作能够有效地利用计算机越来越充足的内存减轻数据库服务器的负担。由于数据操作都是在内存中进行的，然后批量提交到数据源，因此灵活性和性能都有了很大的提高。RowSet默认是一个可滚动、可更新、可序列化的结果集，而且它作为一个JavaBean组件，可以方便地在网络间传输，用于两端的数据同步。通俗来讲，RowSet就相当于数据库表数据在应用程序内存中的映射，我们所有的操作都可以直接与RowSet对象交互。RowSet与数据库之间的数据同步，作为开发人员不需要关注。
+ RowSetEvent
+ RowSetInternal
+ RowSetListener
+ RowSetMetaData
+ RowSetReader
+ RowSetWriter


分布式扩展
+ XAConnection
+ XADataSource 该实例返回的Connection对象能够支持分布式事务。

上面三个都是接口。

### 需要掌握的 API

java.sql.Wrapper

java.sql.Connection

java.sql.Statement

java.sql.PrepareStatement

java.sql.CallableStatement

java.sql.DatabaseMetaData

java.sql.ParameterMetaData

java.sql.ResultSet

java.sql.ResultSetMetaData

这些接口都继承了java.sql.Wrapper接口，里面有两个方法

```java
/**
* unwrap()方法用于返回未经过包装的JDBC驱动原始类型实例，可以通过该实例调用JDBC驱动中提供的非标准的方法。
*/
<T> T unwrap(java.lang.Class<T> iface) throws java.sql.SQLException;
/**
* 用于判断当前实例是否是JDBC驱动中某一类型的包装类型
*/
boolean isWrapperFor(java.lang.Class<?> iface) throws java.sql.SQLException;
```

## JNDI

JNDI（Java Naming and Directory Interface，Java命名和目录接口）为应用程序提供了一种通过网络访问远程服务的方式。

## RMI

## Servlet

## JTA(Java Transaction Architecture)

 JTA定义了一种标准的API，应用系统由此可以访问各种事务监控。

## JTS(Java Transaction Service)

 参考 https://www.ibm.com/developerworks/cn/java/j2ee/

# 容器化

## Docker

## Kubernetes （K8s，K3s）

 Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。

K8s + docker 实现 Pass。

[用树莓派搭建 K3s](https://shumeipai.nxez.com/2020/04/15/kubernetes-raspberry-pi-k3s.html)

## Fass、Saas、Pass

### Function as service

功能即服务是一类云计算服务，它提供了一个平台，允许客户开发，运行和管理应用程序功能，而无需构建和维护通常与开发和启动应用程序相关的基础结构的复杂性。按照此模型构建应用程序是实现“无服务器”体系结构的一种方法，通常在构建微服务应用程序时使用。

**Function as a service** (**FaaS**) is a category of [cloud computing services](https://en.wikipedia.org/wiki/Cloud_computing#Service_models) that provides a [platform](https://en.wikipedia.org/wiki/Computing_platform) allowing customers to develop, run, and manage application functionalities without the complexity of building and maintaining the infrastructure typically associated with developing and launching an app.[[1\]](https://en.wikipedia.org/wiki/Function_as_a_service#cite_note-1) Building an application following this model is one way of achieving a "[serverless](https://en.wikipedia.org/wiki/Serverless_computing)" architecture, and is typically used when building [microservices](https://en.wikipedia.org/wiki/Microservices) applications.

### Software as a service

**软件即服务**Software as a Service，亦可称为“按需即用软件”（即“一经要求，即可使用”）软件即服务，它是一种[软件](https://zh.wikipedia.org/wiki/软件)交付模式。在这种交付模式中，软件仅需通过网络，不须经过传统的安装步骤即可使用，软件及其相关的[数据](https://zh.wikipedia.org/wiki/数据)集中[托管](https://zh.wikipedia.org/wiki/互联网托管服务)于[云端](https://zh.wikipedia.org/wiki/云计算)服务。用户通常使用[精简客户端](https://zh.wikipedia.org/wiki/精簡客戶端)，一般即经由[网页浏览器](https://zh.wikipedia.org/wiki/网页浏览器)来访问、访问软件即服务。SaaS 最大的特色在于软件本身并没有被下载到用户的硬盘，而是存储在提供商的云端或者服务器。对比传统软件需要花钱购买，下载。软件即服务只需要用户租用软件，在线使用，不但大大减少了用户购买风险, 也无需下载软件本身，无设备要求的限制。

### Platform as a service 

**平台即服务**，是一种[云计算](https://zh.wikipedia.org/wiki/雲端運算)服务，提供运算平台与解决方案服务。在云计算的典型层级中，PaaS层介于[软件即服务](https://zh.wikipedia.org/wiki/軟體即服務)与[基础设施即服务](https://zh.wikipedia.org/wiki/基礎設施即服務)之间。

PaaS提供用户将云端基础设施部署与创建至客户端，或者借此获得使用[编程语言](https://zh.wikipedia.org/wiki/程式語言)、[程序库](https://zh.wikipedia.org/wiki/程式庫)与服务。用户不需要管理与控制云端基础设施（包含网络、服务器、操作系统或存储），但需要控制上层的应用程序部署与应用托管的环境。[[1\]](https://zh.wikipedia.org/wiki/平台即服务#cite_note-nist-1)

PaaS将软件研发的平台做为一种服务，以[软件即服务](https://zh.wikipedia.org/wiki/軟體即服務)（SaaS）模式交付给用户。因此，PaaS也是SaaS模式的一种应用。但是，PaaS的出现可以加快SaaS的发展，尤其是加快SaaS应用的开发速度。

PaaS 提供软件部署平台（runtime），抽象掉了硬件和操作系统细节，可以无缝地扩展（scaling）。开发者只需要关注自己的业务逻辑，不需要关注底层。下面这些都属于 PaaS。

## Serverless

## SPI

SPI（Service Provider Interface）是JDK内置的一种服务提供发现机制。SPI是一种动态替换发现的机制。