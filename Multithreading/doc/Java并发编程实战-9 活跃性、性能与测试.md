

# 前言

GUI 的看了，就 Copy-On-Write 提了。

# 死锁

## 定义

一组互相竞争资源的线程因互相等待，导致”永久“阻塞的现象。

## 例子说明

每个人都拥有其他人需要的资源，同时又等待其他人已经拥有的资源，并且每个人在获得所有需要的资源之前都不会放弃已经拥有的资源。

当一个线程永远地持有一个锁，并且其他线程都尝试获得这个锁时，那么他们将永远被阻塞。

## 死锁发生的四个必要条件

1. 互斥，共享资源 X 和 Y 只能被一个线程占用；
2. 占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；
3. 不可抢占，其他线程不能强行抢占线程 T1 占有的资源
4. 循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。

只要破坏其中一个条件，那么死锁就会被破坏。

**解决死锁的办法就是重启应用。**

## 锁顺序死锁

如果每个线程按指定顺序获取锁，就不会出现锁顺序死锁的问题。

### 支持定时的锁

Lock#tryLock(timeout)

### 通过线程转储信息来分析死锁

Thread Dump。

## 其他活跃性的危险

### 饥饿

最长见的资源就是 CPU 时钟周期。如果在 Java 应用程序中对线程的优先级使用不当，或者在持有锁时一些无法结束的结构（例如无限循环，或者无限制地等待某个资源），那么也可能导致饥饿，因为其他需要这个锁的线程将无法得到它。

**要避免使用线程优先级，因为这会增加平台依赖性，并可能导致活跃性问题。在大多数并发应用程序中，都可以使用默认的线程优先级。**

### 糟糕的响应性

对一个大容器进行迭代，并且对每个元素进行计算密集的处理，这会导致糟糕的响应性的其中之一的方式。

### 活锁

活锁（LiveLock）是另一种形式的活跃性问题，该问题尽管不会阻塞线程，但也不能继续执行，因为线程将不断重复执行相同的操作，而且总会失败。

活锁通常发生在处理事务消息的应用程序中：如果不能成功地处理某个消息，那么消息处理机制将会回滚整个事务，并将它重新放到队列的开头。如果消息处理器在处理某种特定类型的消息时存在错误并导致它失败，那么每当这个消息从队列中去取出并传递到存在错误的处理器时，都会发生事务回滚。

避免活锁可以增加随机等待时间来回退